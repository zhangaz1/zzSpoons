[
  {
    "Command": [],
    "Constant": [],
    "Constructor": [],
    "Deprecated": [],
    "Field": [],
    "Function": [],
    "Method": [
      {
        "def": "ColorPicker:bindHotkeys(mapping)",
        "desc": "Binds hotkeys for ColorPicker",
        "doc": "Binds hotkeys for ColorPicker\n\nParameters:\n * mapping - A table containing hotkey objifier/key details for the following items:\n  * show - Show color picker menu",
        "name": "bindHotkeys",
        "parameters": [
          " * mapping - A table containing hotkey objifier/key details for the following items:",
          "  * show - Show color picker menu"
        ],
        "signature": "ColorPicker:bindHotkeys(mapping)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "ColorPicker.toggleColorSamples(tablename)",
        "desc": "Toggle display on the screen of a grid with all the colors in the given colortable",
        "doc": "Toggle display on the screen of a grid with all the colors in the given colortable\n\nParameters:\n * tablename - name of the colortable to display",
        "name": "toggleColorSamples",
        "parameters": [
          " * tablename - name of the colortable to display"
        ],
        "signature": "ColorPicker.toggleColorSamples(tablename)",
        "stripped_doc": "",
        "type": "Method"
      }
    ],
    "Variable": [
      {
        "def": "ColorPicker.logger",
        "desc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "doc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "name": "logger",
        "signature": "ColorPicker.logger",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "ColorPicker.menubar_title",
        "desc": "Title to show in the menubar if `show_in_menubar` is true. Defaults to `\"\\u{1F308}\"`, which is the [Rainbow Emoji](http://emojipedia.org/rainbow/)",
        "doc": "Title to show in the menubar if `show_in_menubar` is true. Defaults to `\"\\u{1F308}\"`, which is the [Rainbow Emoji](http://emojipedia.org/rainbow/)",
        "name": "menubar_title",
        "signature": "ColorPicker.menubar_title",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "ColorPicker.show_in_menubar",
        "desc": "If `true`, show an icon in the menubar to trigger the color picker",
        "doc": "If `true`, show an icon in the menubar to trigger the color picker",
        "name": "show_in_menubar",
        "signature": "ColorPicker.show_in_menubar",
        "stripped_doc": "",
        "type": "Variable"
      }
    ],
    "desc": "Show a color sample/picker",
    "doc": "Show a color sample/picker\n\nClicking on any color will copy its name to the clipboard, cmd-click will copy its RGB code.\n\nDownload: [https://github.com/Hammerspoon/Spoons/raw/master/Spoons/ColorPicker.spoon.zip](https://github.com/Hammerspoon/Spoons/raw/master/Spoons/ColorPicker.spoon.zip)",
    "items": [
      {
        "def": "ColorPicker:bindHotkeys(mapping)",
        "desc": "Binds hotkeys for ColorPicker",
        "doc": "Binds hotkeys for ColorPicker\n\nParameters:\n * mapping - A table containing hotkey objifier/key details for the following items:\n  * show - Show color picker menu",
        "name": "bindHotkeys",
        "parameters": [
          " * mapping - A table containing hotkey objifier/key details for the following items:",
          "  * show - Show color picker menu"
        ],
        "signature": "ColorPicker:bindHotkeys(mapping)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "ColorPicker.logger",
        "desc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "doc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "name": "logger",
        "signature": "ColorPicker.logger",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "ColorPicker.menubar_title",
        "desc": "Title to show in the menubar if `show_in_menubar` is true. Defaults to `\"\\u{1F308}\"`, which is the [Rainbow Emoji](http://emojipedia.org/rainbow/)",
        "doc": "Title to show in the menubar if `show_in_menubar` is true. Defaults to `\"\\u{1F308}\"`, which is the [Rainbow Emoji](http://emojipedia.org/rainbow/)",
        "name": "menubar_title",
        "signature": "ColorPicker.menubar_title",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "ColorPicker.show_in_menubar",
        "desc": "If `true`, show an icon in the menubar to trigger the color picker",
        "doc": "If `true`, show an icon in the menubar to trigger the color picker",
        "name": "show_in_menubar",
        "signature": "ColorPicker.show_in_menubar",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "ColorPicker.toggleColorSamples(tablename)",
        "desc": "Toggle display on the screen of a grid with all the colors in the given colortable",
        "doc": "Toggle display on the screen of a grid with all the colors in the given colortable\n\nParameters:\n * tablename - name of the colortable to display",
        "name": "toggleColorSamples",
        "parameters": [
          " * tablename - name of the colortable to display"
        ],
        "signature": "ColorPicker.toggleColorSamples(tablename)",
        "stripped_doc": "",
        "type": "Method"
      }
    ],
    "name": "ColorPicker",
    "stripped_doc": "\nClicking on any color will copy its name to the clipboard, cmd-click will copy its RGB code.\n\nDownload: [https://github.com/Hammerspoon/Spoons/raw/master/Spoons/ColorPicker.spoon.zip](https://github.com/Hammerspoon/Spoons/raw/master/Spoons/ColorPicker.spoon.zip)",
    "submodules": [],
    "type": "Module"
  },
  {
    "Command": [],
    "Constant": [],
    "Constructor": [],
    "Deprecated": [],
    "Field": [],
    "Function": [],
    "Method": [
      {
        "def": "EvernoteOpenAndTag:bindHotkeys(mapping)",
        "desc": "Binds hotkeys for EvernoteOpenAndTag",
        "doc": "Binds hotkeys for EvernoteOpenAndTag\n\nParameters:\n * mapping - A table containing hotkey objifier/key details for the following items:\n  * `open_note` - open the current note in a new window\n  * `open_and_tag-<tag1>,<tag2>...` - open the current note and apply all the comma-separated tags given. The tags must already exist in Evernote for the tagging to succeed.\n  * `tag-<tag1>,<tag2>...` - open the current note and apply all the comma-separated tags given. The tags must already exist in Evernote for the tagging to succeed.",
        "name": "bindHotkeys",
        "parameters": [
          " * mapping - A table containing hotkey objifier/key details for the following items:",
          "  * `open_note` - open the current note in a new window",
          "  * `open_and_tag-<tag1>,<tag2>...` - open the current note and apply all the comma-separated tags given. The tags must already exist in Evernote for the tagging to succeed.",
          "  * `tag-<tag1>,<tag2>...` - open the current note and apply all the comma-separated tags given. The tags must already exist in Evernote for the tagging to succeed."
        ],
        "signature": "EvernoteOpenAndTag:bindHotkeys(mapping)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "EvernoteOpenAndTag:evernoteIsFrontmost()",
        "desc": "Returns `true` if Evernote is the frontmost application",
        "doc": "Returns `true` if Evernote is the frontmost application\n\nParameters:\n * None\n\nReturns:\n * `true` if Evernote is the frontmost application, `false` otherwise",
        "name": "evernoteIsFrontmost",
        "parameters": [
          " * None"
        ],
        "returns": [
          " * `true` if Evernote is the frontmost application, `false` otherwise"
        ],
        "signature": "EvernoteOpenAndTag:evernoteIsFrontmost()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "EvernoteOpenAndTag:inlineTagCurrentNote(tags)",
        "desc": "Apply the given tags to the selected Evernote notes",
        "doc": "Apply the given tags to the selected Evernote notes\n\nParameters:\n * tags - a table containing a list of tags to apply. The tags must already exist in Evernote.\n\nReturns:\n * None\n\nNotes:\n * If multiple notes are selected, the tags are applied to all of them",
        "name": "inlineTagCurrentNote",
        "notes": [
          " * If multiple notes are selected, the tags are applied to all of them"
        ],
        "parameters": [
          " * tags - a table containing a list of tags to apply. The tags must already exist in Evernote."
        ],
        "returns": [
          " * None"
        ],
        "signature": "EvernoteOpenAndTag:inlineTagCurrentNote(tags)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "EvernoteOpenAndTag:openAndTagCurrentNote(tags)",
        "desc": "Open the current Evernote note in a new window and apply the given tags to it",
        "doc": "Open the current Evernote note in a new window and apply the given tags to it\n\nParameters:\n * tags - a table containing a list of tags to apply. The tags must already exist in Evernote.\n\nReturns:\n * None\n\nNotes:\n * Even if multiple notes are selected, only the first one is tagged, as it will become the \"current one\" after it's opened in a new window",
        "name": "openAndTagCurrentNote",
        "notes": [
          " * Even if multiple notes are selected, only the first one is tagged, as it will become the \"current one\" after it's opened in a new window"
        ],
        "parameters": [
          " * tags - a table containing a list of tags to apply. The tags must already exist in Evernote."
        ],
        "returns": [
          " * None"
        ],
        "signature": "EvernoteOpenAndTag:openAndTagCurrentNote(tags)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "EvernoteOpenAndTag:openCurrentNoteInWindow()",
        "desc": "Open the currently-selected Evernote notes in new windows.",
        "doc": "Open the currently-selected Evernote notes in new windows.\nUses Applescript from https://discussion.evernote.com/topic/85685-feature-request-open-note-in-separate-window-keyboard-shortcut/#comment-366797\n\nParameters:\n * None\n\nReturns:\n * None",
        "name": "openCurrentNoteInWindow",
        "parameters": [
          " * None"
        ],
        "returns": [
          " * None"
        ],
        "signature": "EvernoteOpenAndTag:openCurrentNoteInWindow()",
        "stripped_doc": "Uses Applescript from https://discussion.evernote.com/topic/85685-feature-request-open-note-in-separate-window-keyboard-shortcut/#comment-366797",
        "type": "Method"
      },
      {
        "def": "EvernoteOpenAndTag:tagCurrentNote(tags)",
        "desc": "Assigns tags to the currently-selected Evernote notes",
        "doc": "Assigns tags to the currently-selected Evernote notes\n\nParameters:\n * tags - a table containing a list of tags to apply. The tags must already exist in Evernote.\n\nReturns:\n * None",
        "name": "tagCurrentNote",
        "parameters": [
          " * tags - a table containing a list of tags to apply. The tags must already exist in Evernote."
        ],
        "returns": [
          " * None"
        ],
        "signature": "EvernoteOpenAndTag:tagCurrentNote(tags)",
        "stripped_doc": "",
        "type": "Method"
      }
    ],
    "Variable": [
      {
        "def": "EvernoteOpenAndTag.logger",
        "desc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "doc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "name": "logger",
        "signature": "EvernoteOpenAndTag.logger",
        "stripped_doc": "",
        "type": "Variable"
      }
    ],
    "desc": "Add some missing hotkeys for opening a note in Evernote, and for common tag sets",
    "doc": "Add some missing hotkeys for opening a note in Evernote, and for common tag sets\n\nDownload: [https://github.com/Hammerspoon/Spoons/raw/master/Spoons/EvernoteOpenAndTag.spoon.zip](https://github.com/Hammerspoon/Spoons/raw/master/Spoons/EvernoteOpenAndTag.spoon.zip)",
    "items": [
      {
        "def": "EvernoteOpenAndTag:bindHotkeys(mapping)",
        "desc": "Binds hotkeys for EvernoteOpenAndTag",
        "doc": "Binds hotkeys for EvernoteOpenAndTag\n\nParameters:\n * mapping - A table containing hotkey objifier/key details for the following items:\n  * `open_note` - open the current note in a new window\n  * `open_and_tag-<tag1>,<tag2>...` - open the current note and apply all the comma-separated tags given. The tags must already exist in Evernote for the tagging to succeed.\n  * `tag-<tag1>,<tag2>...` - open the current note and apply all the comma-separated tags given. The tags must already exist in Evernote for the tagging to succeed.",
        "name": "bindHotkeys",
        "parameters": [
          " * mapping - A table containing hotkey objifier/key details for the following items:",
          "  * `open_note` - open the current note in a new window",
          "  * `open_and_tag-<tag1>,<tag2>...` - open the current note and apply all the comma-separated tags given. The tags must already exist in Evernote for the tagging to succeed.",
          "  * `tag-<tag1>,<tag2>...` - open the current note and apply all the comma-separated tags given. The tags must already exist in Evernote for the tagging to succeed."
        ],
        "signature": "EvernoteOpenAndTag:bindHotkeys(mapping)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "EvernoteOpenAndTag:evernoteIsFrontmost()",
        "desc": "Returns `true` if Evernote is the frontmost application",
        "doc": "Returns `true` if Evernote is the frontmost application\n\nParameters:\n * None\n\nReturns:\n * `true` if Evernote is the frontmost application, `false` otherwise",
        "name": "evernoteIsFrontmost",
        "parameters": [
          " * None"
        ],
        "returns": [
          " * `true` if Evernote is the frontmost application, `false` otherwise"
        ],
        "signature": "EvernoteOpenAndTag:evernoteIsFrontmost()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "EvernoteOpenAndTag:inlineTagCurrentNote(tags)",
        "desc": "Apply the given tags to the selected Evernote notes",
        "doc": "Apply the given tags to the selected Evernote notes\n\nParameters:\n * tags - a table containing a list of tags to apply. The tags must already exist in Evernote.\n\nReturns:\n * None\n\nNotes:\n * If multiple notes are selected, the tags are applied to all of them",
        "name": "inlineTagCurrentNote",
        "notes": [
          " * If multiple notes are selected, the tags are applied to all of them"
        ],
        "parameters": [
          " * tags - a table containing a list of tags to apply. The tags must already exist in Evernote."
        ],
        "returns": [
          " * None"
        ],
        "signature": "EvernoteOpenAndTag:inlineTagCurrentNote(tags)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "EvernoteOpenAndTag.logger",
        "desc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "doc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "name": "logger",
        "signature": "EvernoteOpenAndTag.logger",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "EvernoteOpenAndTag:openAndTagCurrentNote(tags)",
        "desc": "Open the current Evernote note in a new window and apply the given tags to it",
        "doc": "Open the current Evernote note in a new window and apply the given tags to it\n\nParameters:\n * tags - a table containing a list of tags to apply. The tags must already exist in Evernote.\n\nReturns:\n * None\n\nNotes:\n * Even if multiple notes are selected, only the first one is tagged, as it will become the \"current one\" after it's opened in a new window",
        "name": "openAndTagCurrentNote",
        "notes": [
          " * Even if multiple notes are selected, only the first one is tagged, as it will become the \"current one\" after it's opened in a new window"
        ],
        "parameters": [
          " * tags - a table containing a list of tags to apply. The tags must already exist in Evernote."
        ],
        "returns": [
          " * None"
        ],
        "signature": "EvernoteOpenAndTag:openAndTagCurrentNote(tags)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "EvernoteOpenAndTag:openCurrentNoteInWindow()",
        "desc": "Open the currently-selected Evernote notes in new windows.",
        "doc": "Open the currently-selected Evernote notes in new windows.\nUses Applescript from https://discussion.evernote.com/topic/85685-feature-request-open-note-in-separate-window-keyboard-shortcut/#comment-366797\n\nParameters:\n * None\n\nReturns:\n * None",
        "name": "openCurrentNoteInWindow",
        "parameters": [
          " * None"
        ],
        "returns": [
          " * None"
        ],
        "signature": "EvernoteOpenAndTag:openCurrentNoteInWindow()",
        "stripped_doc": "Uses Applescript from https://discussion.evernote.com/topic/85685-feature-request-open-note-in-separate-window-keyboard-shortcut/#comment-366797",
        "type": "Method"
      },
      {
        "def": "EvernoteOpenAndTag:tagCurrentNote(tags)",
        "desc": "Assigns tags to the currently-selected Evernote notes",
        "doc": "Assigns tags to the currently-selected Evernote notes\n\nParameters:\n * tags - a table containing a list of tags to apply. The tags must already exist in Evernote.\n\nReturns:\n * None",
        "name": "tagCurrentNote",
        "parameters": [
          " * tags - a table containing a list of tags to apply. The tags must already exist in Evernote."
        ],
        "returns": [
          " * None"
        ],
        "signature": "EvernoteOpenAndTag:tagCurrentNote(tags)",
        "stripped_doc": "",
        "type": "Method"
      }
    ],
    "name": "EvernoteOpenAndTag",
    "stripped_doc": "\nDownload: [https://github.com/Hammerspoon/Spoons/raw/master/Spoons/EvernoteOpenAndTag.spoon.zip](https://github.com/Hammerspoon/Spoons/raw/master/Spoons/EvernoteOpenAndTag.spoon.zip)",
    "submodules": [],
    "type": "Module"
  },
  {
    "Command": [],
    "Constant": [],
    "Constructor": [],
    "Deprecated": [],
    "Field": [],
    "Function": [],
    "Method": [
      {
        "def": "FadeLogo:delete()",
        "desc": "Hide and delete the canvas",
        "doc": "Hide and delete the canvas",
        "name": "delete",
        "signature": "FadeLogo:delete()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "FadeLogo:hide()",
        "desc": "Hide the image without zoom, fading it out over `fade_out_time` seconds",
        "doc": "Hide the image without zoom, fading it out over `fade_out_time` seconds",
        "name": "hide",
        "signature": "FadeLogo:hide()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "FadeLogo:show()",
        "desc": "Display the image, fading it in over `fade_in_time` seconds",
        "doc": "Display the image, fading it in over `fade_in_time` seconds",
        "name": "show",
        "signature": "FadeLogo:show()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "FadeLogo:start()",
        "desc": "Show the image, wait `run_time` seconds, and then zoom-and-fade it out.",
        "doc": "Show the image, wait `run_time` seconds, and then zoom-and-fade it out.",
        "name": "start",
        "signature": "FadeLogo:start()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "FadeLogo:zoom_and_fade()",
        "desc": "Zoom-and-fade the image over `fade_out_time` seconds",
        "doc": "Zoom-and-fade the image over `fade_out_time` seconds",
        "name": "zoom_and_fade",
        "signature": "FadeLogo:zoom_and_fade()",
        "stripped_doc": "",
        "type": "Method"
      }
    ],
    "Variable": [
      {
        "def": "FadeLogo.fade_in_time",
        "desc": "Number of seconds over which to fade in the image. Defaults to 0.3.",
        "doc": "Number of seconds over which to fade in the image. Defaults to 0.3.",
        "name": "fade_in_time",
        "signature": "FadeLogo.fade_in_time",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "FadeLogo.fade_out_time",
        "desc": "Number of seconds over which to fade out the image. Defaults to 0.5.",
        "doc": "Number of seconds over which to fade out the image. Defaults to 0.5.",
        "name": "fade_out_time",
        "signature": "FadeLogo.fade_out_time",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "FadeLogo.image",
        "desc": "Image to display. Must be an `hs.image` object. Defaults to `hs.image.imageFromName(hs.image.systemImageNames.ApplicationIcon)` (the Hammerspoon app icon)",
        "doc": "Image to display. Must be an `hs.image` object. Defaults to `hs.image.imageFromName(hs.image.systemImageNames.ApplicationIcon)` (the Hammerspoon app icon)",
        "name": "image",
        "signature": "FadeLogo.image",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "FadeLogo.image_alpha",
        "desc": "Initial transparency of the image. Defaults to 1.0.",
        "doc": "Initial transparency of the image. Defaults to 1.0.",
        "name": "image_alpha",
        "signature": "FadeLogo.image_alpha",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "FadeLogo.image_size",
        "desc": "`hs.geometry` object specifying the initial size of the image to display in the center of the screen. The image object will be resizes proportionally to fit in this size. Defaults to `hs.geometry.size(w=200, h=200)`",
        "doc": "`hs.geometry` object specifying the initial size of the image to display in the center of the screen. The image object will be resizes proportionally to fit in this size. Defaults to `hs.geometry.size(w=200, h=200)`",
        "name": "image_size",
        "signature": "FadeLogo.image_size",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "FadeLogo.logger",
        "desc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "doc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "name": "logger",
        "signature": "FadeLogo.logger",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "FadeLogo.run_time",
        "desc": "Number of seconds to leave the image on the screen when `start()` is called.",
        "doc": "Number of seconds to leave the image on the screen when `start()` is called.",
        "name": "run_time",
        "signature": "FadeLogo.run_time",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "FadeLogo.zoom",
        "desc": "Do zoom-and-fade if `true`, otherwise do a regular fade",
        "doc": "Do zoom-and-fade if `true`, otherwise do a regular fade",
        "name": "zoom",
        "signature": "FadeLogo.zoom",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "FadeLogo.zoom_scale_factor",
        "desc": "Factor by which to scale the image at every iteration during the zoom-and-fade. Defaults to 1.1.",
        "doc": "Factor by which to scale the image at every iteration during the zoom-and-fade. Defaults to 1.1.",
        "name": "zoom_scale_factor",
        "signature": "FadeLogo.zoom_scale_factor",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "FadeLogo.zoom_scale_timer",
        "desc": "Seconds between the zooming iterations",
        "doc": "Seconds between the zooming iterations",
        "name": "zoom_scale_timer",
        "signature": "FadeLogo.zoom_scale_timer",
        "stripped_doc": "",
        "type": "Variable"
      }
    ],
    "desc": "Show a fading-and-zooming image in the center of the screen",
    "doc": "Show a fading-and-zooming image in the center of the screen\n\nBy default the Hammerspoon logo is shown. Typical use is to show it as an indicator when your configuration finishes loading, by adding the following to the bottom of your `~/.hammerspoon/init.lua` file:\n```\n  hs.loadSpoon('FadeLogo'):start()\n```\nWhich looks like this: http://imgur.com/a/TbZOl\n\nDownload: [https://github.com/Hammerspoon/Spoons/raw/master/Spoons/FadeLogo.spoon.zip](https://github.com/Hammerspoon/Spoons/raw/master/Spoons/FadeLogo.spoon.zip)",
    "items": [
      {
        "def": "FadeLogo:delete()",
        "desc": "Hide and delete the canvas",
        "doc": "Hide and delete the canvas",
        "name": "delete",
        "signature": "FadeLogo:delete()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "FadeLogo.fade_in_time",
        "desc": "Number of seconds over which to fade in the image. Defaults to 0.3.",
        "doc": "Number of seconds over which to fade in the image. Defaults to 0.3.",
        "name": "fade_in_time",
        "signature": "FadeLogo.fade_in_time",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "FadeLogo.fade_out_time",
        "desc": "Number of seconds over which to fade out the image. Defaults to 0.5.",
        "doc": "Number of seconds over which to fade out the image. Defaults to 0.5.",
        "name": "fade_out_time",
        "signature": "FadeLogo.fade_out_time",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "FadeLogo:hide()",
        "desc": "Hide the image without zoom, fading it out over `fade_out_time` seconds",
        "doc": "Hide the image without zoom, fading it out over `fade_out_time` seconds",
        "name": "hide",
        "signature": "FadeLogo:hide()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "FadeLogo.image",
        "desc": "Image to display. Must be an `hs.image` object. Defaults to `hs.image.imageFromName(hs.image.systemImageNames.ApplicationIcon)` (the Hammerspoon app icon)",
        "doc": "Image to display. Must be an `hs.image` object. Defaults to `hs.image.imageFromName(hs.image.systemImageNames.ApplicationIcon)` (the Hammerspoon app icon)",
        "name": "image",
        "signature": "FadeLogo.image",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "FadeLogo.image_alpha",
        "desc": "Initial transparency of the image. Defaults to 1.0.",
        "doc": "Initial transparency of the image. Defaults to 1.0.",
        "name": "image_alpha",
        "signature": "FadeLogo.image_alpha",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "FadeLogo.image_size",
        "desc": "`hs.geometry` object specifying the initial size of the image to display in the center of the screen. The image object will be resizes proportionally to fit in this size. Defaults to `hs.geometry.size(w=200, h=200)`",
        "doc": "`hs.geometry` object specifying the initial size of the image to display in the center of the screen. The image object will be resizes proportionally to fit in this size. Defaults to `hs.geometry.size(w=200, h=200)`",
        "name": "image_size",
        "signature": "FadeLogo.image_size",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "FadeLogo.logger",
        "desc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "doc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "name": "logger",
        "signature": "FadeLogo.logger",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "FadeLogo.run_time",
        "desc": "Number of seconds to leave the image on the screen when `start()` is called.",
        "doc": "Number of seconds to leave the image on the screen when `start()` is called.",
        "name": "run_time",
        "signature": "FadeLogo.run_time",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "FadeLogo:show()",
        "desc": "Display the image, fading it in over `fade_in_time` seconds",
        "doc": "Display the image, fading it in over `fade_in_time` seconds",
        "name": "show",
        "signature": "FadeLogo:show()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "FadeLogo:start()",
        "desc": "Show the image, wait `run_time` seconds, and then zoom-and-fade it out.",
        "doc": "Show the image, wait `run_time` seconds, and then zoom-and-fade it out.",
        "name": "start",
        "signature": "FadeLogo:start()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "FadeLogo.zoom",
        "desc": "Do zoom-and-fade if `true`, otherwise do a regular fade",
        "doc": "Do zoom-and-fade if `true`, otherwise do a regular fade",
        "name": "zoom",
        "signature": "FadeLogo.zoom",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "FadeLogo:zoom_and_fade()",
        "desc": "Zoom-and-fade the image over `fade_out_time` seconds",
        "doc": "Zoom-and-fade the image over `fade_out_time` seconds",
        "name": "zoom_and_fade",
        "signature": "FadeLogo:zoom_and_fade()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "FadeLogo.zoom_scale_factor",
        "desc": "Factor by which to scale the image at every iteration during the zoom-and-fade. Defaults to 1.1.",
        "doc": "Factor by which to scale the image at every iteration during the zoom-and-fade. Defaults to 1.1.",
        "name": "zoom_scale_factor",
        "signature": "FadeLogo.zoom_scale_factor",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "FadeLogo.zoom_scale_timer",
        "desc": "Seconds between the zooming iterations",
        "doc": "Seconds between the zooming iterations",
        "name": "zoom_scale_timer",
        "signature": "FadeLogo.zoom_scale_timer",
        "stripped_doc": "",
        "type": "Variable"
      }
    ],
    "name": "FadeLogo",
    "stripped_doc": "\nBy default the Hammerspoon logo is shown. Typical use is to show it as an indicator when your configuration finishes loading, by adding the following to the bottom of your `~/.hammerspoon/init.lua` file:\n```\n  hs.loadSpoon('FadeLogo'):start()\n```\nWhich looks like this: http://imgur.com/a/TbZOl\n\nDownload: [https://github.com/Hammerspoon/Spoons/raw/master/Spoons/FadeLogo.spoon.zip](https://github.com/Hammerspoon/Spoons/raw/master/Spoons/FadeLogo.spoon.zip)",
    "submodules": [],
    "type": "Module"
  },
  {
    "Command": [],
    "Constant": [],
    "Constructor": [],
    "Deprecated": [],
    "Field": [],
    "Function": [],
    "Method": [
      {
        "def": "Hammer:autoReloadConfig(files)",
        "desc": "Reload config only if any of the Lua files in `files` have changed",
        "doc": "Reload config only if any of the Lua files in `files` have changed",
        "name": "autoReloadConfig",
        "signature": "Hammer:autoReloadConfig(files)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "Hammer:bindHotkeys(mapping)",
        "desc": "Binds hotkeys for Hammer",
        "doc": "Binds hotkeys for Hammer\n\nParameters:\n * mapping - A table containing hotkey objifier/key details for the following items:\n  * config_reload - Manually trigger a config reload",
        "name": "bindHotkeys",
        "parameters": [
          " * mapping - A table containing hotkey objifier/key details for the following items:",
          "  * config_reload - Manually trigger a config reload"
        ],
        "signature": "Hammer:bindHotkeys(mapping)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "Hammer:reloadConfig()",
        "desc": "Manually reload configuration (wrapper around `hs.reload`)",
        "doc": "Manually reload configuration (wrapper around `hs.reload`)",
        "name": "reloadConfig",
        "signature": "Hammer:reloadConfig()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "Hammer:start()",
        "desc": "Start the Spoon. At the moment this includes:",
        "doc": "Start the Spoon. At the moment this includes:\n * Set up the file watcher for auto-config-reload",
        "name": "start",
        "signature": "Hammer:start()",
        "stripped_doc": " * Set up the file watcher for auto-config-reload",
        "type": "Method"
      }
    ],
    "Variable": [
      {
        "def": "Hammer.auto_reload_config",
        "desc": "If true, automatically reload Hammerspoon config when any `.lua` files inside `hs.configdir` changes",
        "doc": "If true, automatically reload Hammerspoon config when any `.lua` files inside `hs.configdir` changes",
        "name": "auto_reload_config",
        "signature": "Hammer.auto_reload_config",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "Hammer.install_cli",
        "desc": "If true, install the `hs` command line tool",
        "doc": "If true, install the `hs` command line tool",
        "name": "install_cli",
        "signature": "Hammer.install_cli",
        "stripped_doc": "",
        "type": "Variable"
      }
    ],
    "desc": "Automate some Hammerspoon configuration tasks",
    "doc": "Automate some Hammerspoon configuration tasks\n\nDownload: [https://github.com/Hammerspoon/Spoons/raw/master/Spoons/Hammer.spoon.zip](https://github.com/Hammerspoon/Spoons/raw/master/Spoons/Hammer.spoon.zip)",
    "items": [
      {
        "def": "Hammer.auto_reload_config",
        "desc": "If true, automatically reload Hammerspoon config when any `.lua` files inside `hs.configdir` changes",
        "doc": "If true, automatically reload Hammerspoon config when any `.lua` files inside `hs.configdir` changes",
        "name": "auto_reload_config",
        "signature": "Hammer.auto_reload_config",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "Hammer:autoReloadConfig(files)",
        "desc": "Reload config only if any of the Lua files in `files` have changed",
        "doc": "Reload config only if any of the Lua files in `files` have changed",
        "name": "autoReloadConfig",
        "signature": "Hammer:autoReloadConfig(files)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "Hammer:bindHotkeys(mapping)",
        "desc": "Binds hotkeys for Hammer",
        "doc": "Binds hotkeys for Hammer\n\nParameters:\n * mapping - A table containing hotkey objifier/key details for the following items:\n  * config_reload - Manually trigger a config reload",
        "name": "bindHotkeys",
        "parameters": [
          " * mapping - A table containing hotkey objifier/key details for the following items:",
          "  * config_reload - Manually trigger a config reload"
        ],
        "signature": "Hammer:bindHotkeys(mapping)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "Hammer.install_cli",
        "desc": "If true, install the `hs` command line tool",
        "doc": "If true, install the `hs` command line tool",
        "name": "install_cli",
        "signature": "Hammer.install_cli",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "Hammer:reloadConfig()",
        "desc": "Manually reload configuration (wrapper around `hs.reload`)",
        "doc": "Manually reload configuration (wrapper around `hs.reload`)",
        "name": "reloadConfig",
        "signature": "Hammer:reloadConfig()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "Hammer:start()",
        "desc": "Start the Spoon. At the moment this includes:",
        "doc": "Start the Spoon. At the moment this includes:\n * Set up the file watcher for auto-config-reload",
        "name": "start",
        "signature": "Hammer:start()",
        "stripped_doc": " * Set up the file watcher for auto-config-reload",
        "type": "Method"
      }
    ],
    "name": "Hammer",
    "stripped_doc": "\nDownload: [https://github.com/Hammerspoon/Spoons/raw/master/Spoons/Hammer.spoon.zip](https://github.com/Hammerspoon/Spoons/raw/master/Spoons/Hammer.spoon.zip)",
    "submodules": [],
    "type": "Module"
  },
  {
    "Command": [],
    "Constant": [],
    "Constructor": [],
    "Deprecated": [],
    "Field": [],
    "Function": [],
    "Method": [
      {
        "def": "HeadphoneWatcher:audiodevwatch(dev_uid, event_name)",
        "desc": "Callback function to use as an audio device watcher, to pause/unpause the application on headphones plugged/unplugged",
        "doc": "Callback function to use as an audio device watcher, to pause/unpause the application on headphones plugged/unplugged",
        "name": "audiodevwatch",
        "signature": "HeadphoneWatcher:audiodevwatch(dev_uid, event_name)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "HeadphoneWatcher.defaultControlFns(app)",
        "desc": "Generate the most common set of application control definition.",
        "doc": "Generate the most common set of application control definition.\n\nParameters:\n * app - name of the application, with its correct letter casing (i.e. \"iTunes\"). The name as provided will be used to find the running application, and its lowercase version will be used to find the corresponding `hs.*` module.\n\nReturns:\n * A table in the correct format for `HeadphoneWatcher.controlfns`, using the lower-case value of `app` as the module name (for example, if app = \"iTunes\", the module loaded will be `hs.itunes`, and assuming the functions `isPlaying()`, `play()` and `pause()` exist in that module.",
        "name": "defaultControlFns",
        "parameters": [
          " * app - name of the application, with its correct letter casing (i.e. \"iTunes\"). The name as provided will be used to find the running application, and its lowercase version will be used to find the corresponding `hs.*` module."
        ],
        "returns": [
          " * A table in the correct format for `HeadphoneWatcher.controlfns`, using the lower-case value of `app` as the module name (for example, if app = \"iTunes\", the module loaded will be `hs.itunes`, and assuming the functions `isPlaying()`, `play()` and `pause()` exist in that module."
        ],
        "signature": "HeadphoneWatcher.defaultControlFns(app)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "HeadphoneWatcher:start()",
        "desc": "Start headphone detection on all audio devices that support it",
        "doc": "Start headphone detection on all audio devices that support it",
        "name": "start",
        "signature": "HeadphoneWatcher:start()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "HeadphoneWatcher:stop()",
        "desc": "Stop headphone detection",
        "doc": "Stop headphone detection",
        "name": "stop",
        "signature": "HeadphoneWatcher:stop()",
        "stripped_doc": "",
        "type": "Method"
      }
    ],
    "Variable": [
      {
        "def": "HeadphoneWatcher.control",
        "desc": "Table containing one key per application, with the value indicating whether HeadphoneWatcher should try to pause/unpause that application in response to the headphone being plugged/unplugged. The key name must ideally correspond to the name of the corresponding `hs.*` module. Default value:",
        "doc": "Table containing one key per application, with the value indicating whether HeadphoneWatcher should try to pause/unpause that application in response to the headphone being plugged/unplugged. The key name must ideally correspond to the name of the corresponding `hs.*` module. Default value:\n```\n{\n   itunes = true,\n   spotify = true,\n   deezer = true,\n   vox = false -- Vox has built-in headphone detection support\n}\n```",
        "name": "control",
        "signature": "HeadphoneWatcher.control",
        "stripped_doc": "```\n{\n   itunes = true,\n   spotify = true,\n   deezer = true,\n   vox = false -- Vox has built-in headphone detection support\n}\n```",
        "type": "Variable"
      },
      {
        "def": "HeadphoneWatcher.controlfns",
        "desc": "Table containing control functions for each application to control.",
        "doc": "Table containing control functions for each application to control.\nThe keys must correspond to the values in `HeadphoneWatcher.control`, and the value is a table with the following elements:\n * `appname` - application name (case-sensitive, as the application appears to the system)\n * `isPlaying` - function that returns a true value if the application is playing\n * `play` - function that starts playback in the application\n * `pause` - function that pauses playback in the application\n\nThe default value includes definitions for iTunes, Spotify, Deezer and Vox, using the corresponding functions from `hs.itunes`, `hs.spotify`, `hs.deezer` and `hs.vox`, respectively.",
        "name": "controlfns",
        "signature": "HeadphoneWatcher.controlfns",
        "stripped_doc": "The keys must correspond to the values in `HeadphoneWatcher.control`, and the value is a table with the following elements:\n * `appname` - application name (case-sensitive, as the application appears to the system)\n * `isPlaying` - function that returns a true value if the application is playing\n * `play` - function that starts playback in the application\n * `pause` - function that pauses playback in the application\nThe default value includes definitions for iTunes, Spotify, Deezer and Vox, using the corresponding functions from `hs.itunes`, `hs.spotify`, `hs.deezer` and `hs.vox`, respectively.",
        "type": "Variable"
      },
      {
        "def": "HeadphoneWatcher.logger",
        "desc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "doc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "name": "logger",
        "signature": "HeadphoneWatcher.logger",
        "stripped_doc": "",
        "type": "Variable"
      }
    ],
    "desc": "Play/pause music players when headphones are connected/disconnected",
    "doc": "Play/pause music players when headphones are connected/disconnected\n\nDownload: [https://github.com/Hammerspoon/Spoons/raw/master/Spoons/HeadphoneWatcher.spoon.zip](https://github.com/Hammerspoon/Spoons/raw/master/Spoons/HeadphoneWatcher.spoon.zip)",
    "items": [
      {
        "def": "HeadphoneWatcher:audiodevwatch(dev_uid, event_name)",
        "desc": "Callback function to use as an audio device watcher, to pause/unpause the application on headphones plugged/unplugged",
        "doc": "Callback function to use as an audio device watcher, to pause/unpause the application on headphones plugged/unplugged",
        "name": "audiodevwatch",
        "signature": "HeadphoneWatcher:audiodevwatch(dev_uid, event_name)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "HeadphoneWatcher.control",
        "desc": "Table containing one key per application, with the value indicating whether HeadphoneWatcher should try to pause/unpause that application in response to the headphone being plugged/unplugged. The key name must ideally correspond to the name of the corresponding `hs.*` module. Default value:",
        "doc": "Table containing one key per application, with the value indicating whether HeadphoneWatcher should try to pause/unpause that application in response to the headphone being plugged/unplugged. The key name must ideally correspond to the name of the corresponding `hs.*` module. Default value:\n```\n{\n   itunes = true,\n   spotify = true,\n   deezer = true,\n   vox = false -- Vox has built-in headphone detection support\n}\n```",
        "name": "control",
        "signature": "HeadphoneWatcher.control",
        "stripped_doc": "```\n{\n   itunes = true,\n   spotify = true,\n   deezer = true,\n   vox = false -- Vox has built-in headphone detection support\n}\n```",
        "type": "Variable"
      },
      {
        "def": "HeadphoneWatcher.controlfns",
        "desc": "Table containing control functions for each application to control.",
        "doc": "Table containing control functions for each application to control.\nThe keys must correspond to the values in `HeadphoneWatcher.control`, and the value is a table with the following elements:\n * `appname` - application name (case-sensitive, as the application appears to the system)\n * `isPlaying` - function that returns a true value if the application is playing\n * `play` - function that starts playback in the application\n * `pause` - function that pauses playback in the application\n\nThe default value includes definitions for iTunes, Spotify, Deezer and Vox, using the corresponding functions from `hs.itunes`, `hs.spotify`, `hs.deezer` and `hs.vox`, respectively.",
        "name": "controlfns",
        "signature": "HeadphoneWatcher.controlfns",
        "stripped_doc": "The keys must correspond to the values in `HeadphoneWatcher.control`, and the value is a table with the following elements:\n * `appname` - application name (case-sensitive, as the application appears to the system)\n * `isPlaying` - function that returns a true value if the application is playing\n * `play` - function that starts playback in the application\n * `pause` - function that pauses playback in the application\nThe default value includes definitions for iTunes, Spotify, Deezer and Vox, using the corresponding functions from `hs.itunes`, `hs.spotify`, `hs.deezer` and `hs.vox`, respectively.",
        "type": "Variable"
      },
      {
        "def": "HeadphoneWatcher.defaultControlFns(app)",
        "desc": "Generate the most common set of application control definition.",
        "doc": "Generate the most common set of application control definition.\n\nParameters:\n * app - name of the application, with its correct letter casing (i.e. \"iTunes\"). The name as provided will be used to find the running application, and its lowercase version will be used to find the corresponding `hs.*` module.\n\nReturns:\n * A table in the correct format for `HeadphoneWatcher.controlfns`, using the lower-case value of `app` as the module name (for example, if app = \"iTunes\", the module loaded will be `hs.itunes`, and assuming the functions `isPlaying()`, `play()` and `pause()` exist in that module.",
        "name": "defaultControlFns",
        "parameters": [
          " * app - name of the application, with its correct letter casing (i.e. \"iTunes\"). The name as provided will be used to find the running application, and its lowercase version will be used to find the corresponding `hs.*` module."
        ],
        "returns": [
          " * A table in the correct format for `HeadphoneWatcher.controlfns`, using the lower-case value of `app` as the module name (for example, if app = \"iTunes\", the module loaded will be `hs.itunes`, and assuming the functions `isPlaying()`, `play()` and `pause()` exist in that module."
        ],
        "signature": "HeadphoneWatcher.defaultControlFns(app)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "HeadphoneWatcher.logger",
        "desc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "doc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "name": "logger",
        "signature": "HeadphoneWatcher.logger",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "HeadphoneWatcher:start()",
        "desc": "Start headphone detection on all audio devices that support it",
        "doc": "Start headphone detection on all audio devices that support it",
        "name": "start",
        "signature": "HeadphoneWatcher:start()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "HeadphoneWatcher:stop()",
        "desc": "Stop headphone detection",
        "doc": "Stop headphone detection",
        "name": "stop",
        "signature": "HeadphoneWatcher:stop()",
        "stripped_doc": "",
        "type": "Method"
      }
    ],
    "name": "HeadphoneWatcher",
    "stripped_doc": "\nDownload: [https://github.com/Hammerspoon/Spoons/raw/master/Spoons/HeadphoneWatcher.spoon.zip](https://github.com/Hammerspoon/Spoons/raw/master/Spoons/HeadphoneWatcher.spoon.zip)",
    "submodules": [],
    "type": "Module"
  },
  {
    "Command": [],
    "Constant": [],
    "Constructor": [],
    "Deprecated": [],
    "Field": [],
    "Function": [],
    "Method": [
      {
        "def": "SpoonInstall:andUse(name, arg)",
        "desc": "Declaratively install, load and configure a Spoon",
        "doc": "Declaratively install, load and configure a Spoon\n\nParameters:\n * name - the name of the Spoon to install (without the `.spoon` extension). If the Spoon is already installed, it will be loaded using `hs.loadSpoon()`. If it is not installed, it will be installed using `SpoonInstall:asyncInstallSpoonFromRepo()` and then loaded.\n * arg - if provided, can be used to specify the configuration of the Spoon. The following keys are recognized (all are optional):\n   * repo - repository from where the Spoon should be installed if not present in the system, as defined in `SpoonInstall.repos`. Defaults to `\"default\"`.\n   * config - a table containing variables to be stored in the Spoon object to configure it. For example, `config = { answer = 42 }` will result in `spoon.<LoadedSpoon>.answer` being set to 42.\n   * hotkeys - a table containing hotkey bindings. If provided, will be passed as-is to the Spoon's `bindHotkeys()` method. The special string `\"default\"` can be given to use the Spoons `defaultHotkeys` variable, if it exists.\n   * fn - a function which will be called with the freshly-loaded Spoon object as its first argument.\n   * loglevel - if the Spoon has a variable called `logger`, its `setLogLevel()` method will be called with this value.\n   * start - if `true`, call the Spoon's `start()` method after configuring everything else.\n   * disable - if `true`, do nothing. Easier than commenting it out when you want to temporarily disable a spoon.\n\nReturns:\n * None",
        "name": "andUse",
        "parameters": [
          " * name - the name of the Spoon to install (without the `.spoon` extension). If the Spoon is already installed, it will be loaded using `hs.loadSpoon()`. If it is not installed, it will be installed using `SpoonInstall:asyncInstallSpoonFromRepo()` and then loaded.",
          " * arg - if provided, can be used to specify the configuration of the Spoon. The following keys are recognized (all are optional):",
          "   * repo - repository from where the Spoon should be installed if not present in the system, as defined in `SpoonInstall.repos`. Defaults to `\"default\"`.",
          "   * config - a table containing variables to be stored in the Spoon object to configure it. For example, `config = { answer = 42 }` will result in `spoon.<LoadedSpoon>.answer` being set to 42.",
          "   * hotkeys - a table containing hotkey bindings. If provided, will be passed as-is to the Spoon's `bindHotkeys()` method. The special string `\"default\"` can be given to use the Spoons `defaultHotkeys` variable, if it exists.",
          "   * fn - a function which will be called with the freshly-loaded Spoon object as its first argument.",
          "   * loglevel - if the Spoon has a variable called `logger`, its `setLogLevel()` method will be called with this value.",
          "   * start - if `true`, call the Spoon's `start()` method after configuring everything else.",
          "   * disable - if `true`, do nothing. Easier than commenting it out when you want to temporarily disable a spoon."
        ],
        "returns": [
          " * None"
        ],
        "signature": "SpoonInstall:andUse(name, arg)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "SpoonInstall:asyncInstallSpoonFromRepo(name, repo, callback)",
        "desc": "Asynchronously install a Spoon from a registered repository",
        "doc": "Asynchronously install a Spoon from a registered repository\n\nParameters:\n * name - Name of the Spoon to install.\n * repo - Name of the repository to use. Defaults to `\"default\"`\n * callback - if given, a function to call after the installation finishes (also if it fails). The function receives the following arguments:\n   * urlparts - Result of calling `hs.http.urlParts` on the URL of the Spoon zip file\n   * success - boolean indicating whether the installation was successful\n\nReturns:\n * `true` if the installation was correctly initiated (i.e. the repo and spoon name were correct), `false` otherwise.",
        "name": "asyncInstallSpoonFromRepo",
        "parameters": [
          " * name - Name of the Spoon to install.",
          " * repo - Name of the repository to use. Defaults to `\"default\"`",
          " * callback - if given, a function to call after the installation finishes (also if it fails). The function receives the following arguments:",
          "   * urlparts - Result of calling `hs.http.urlParts` on the URL of the Spoon zip file",
          "   * success - boolean indicating whether the installation was successful"
        ],
        "returns": [
          " * `true` if the installation was correctly initiated (i.e. the repo and spoon name were correct), `false` otherwise."
        ],
        "signature": "SpoonInstall:asyncInstallSpoonFromRepo(name, repo, callback)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "SpoonInstall:asyncInstallSpoonFromZipURL(url, callback)",
        "desc": "Asynchronously download a Spoon zip file and install it.",
        "doc": "Asynchronously download a Spoon zip file and install it.\n\nParameters:\n * url - URL of the zip file to install.\n * callback - if given, a function to call after the installation finishes (also if it fails). The function receives the following arguments:\n   * urlparts - Result of calling `hs.http.urlParts` on the URL of the Spoon zip file\n   * success - boolean indicating whether the installation was successful\n\nReturns:\n * `true` if the installation was correctly initiated (i.e. the URL is valid), `false` otherwise",
        "name": "asyncInstallSpoonFromZipURL",
        "parameters": [
          " * url - URL of the zip file to install.",
          " * callback - if given, a function to call after the installation finishes (also if it fails). The function receives the following arguments:",
          "   * urlparts - Result of calling `hs.http.urlParts` on the URL of the Spoon zip file",
          "   * success - boolean indicating whether the installation was successful"
        ],
        "returns": [
          " * `true` if the installation was correctly initiated (i.e. the URL is valid), `false` otherwise"
        ],
        "signature": "SpoonInstall:asyncInstallSpoonFromZipURL(url, callback)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "SpoonInstall:asyncUpdateRepo(repo, callback)",
        "desc": "Asynchronously fetch the information about the contents of a Spoon repository",
        "doc": "Asynchronously fetch the information about the contents of a Spoon repository\n\nParameters:\n * repo - name of the repository to update. Defaults to `\"default\"`.\n * callback - if given, a function to be called after the update finishes (also if it fails). The function will receive the following arguments:\n   * repo - name of the repository\n   * success - boolean indicating whether the update succeeded\n\nReturns:\n * `true` if the update was correctly initiated (i.e. the repo name is valid), `nil` otherwise\n\nNotes:\n * For now, the repository data is not persisted, so you need to update it after every restart if you want to use any of the install functions.",
        "name": "asyncUpdateRepo",
        "notes": [
          " * For now, the repository data is not persisted, so you need to update it after every restart if you want to use any of the install functions."
        ],
        "parameters": [
          " * repo - name of the repository to update. Defaults to `\"default\"`.",
          " * callback - if given, a function to be called after the update finishes (also if it fails). The function will receive the following arguments:",
          "   * repo - name of the repository",
          "   * success - boolean indicating whether the update succeeded"
        ],
        "returns": [
          " * `true` if the update was correctly initiated (i.e. the repo name is valid), `nil` otherwise"
        ],
        "signature": "SpoonInstall:asyncUpdateRepo(repo, callback)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "SpoonInstall:installSpoonFromRepo(name, repo)",
        "desc": "Synchronously install a Spoon from a registered repository",
        "doc": "Synchronously install a Spoon from a registered repository\n\nParameters:\n * name = Name of the Spoon to install.\n * repo - Name of the repository to use. Defaults to `\"default\"`\n\nReturns:\n * `true` if the installation was successful, `nil` otherwise.",
        "name": "installSpoonFromRepo",
        "parameters": [
          " * name = Name of the Spoon to install.",
          " * repo - Name of the repository to use. Defaults to `\"default\"`"
        ],
        "returns": [
          " * `true` if the installation was successful, `nil` otherwise."
        ],
        "signature": "SpoonInstall:installSpoonFromRepo(name, repo)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "SpoonInstall:installSpoonFromZipURL(url)",
        "desc": "Synchronously download a Spoon zip file and install it.",
        "doc": "Synchronously download a Spoon zip file and install it.\n\nParameters:\n * url - URL of the zip file to install.\n\nReturns:\n * `true` if the installation was successful, `nil` otherwise",
        "name": "installSpoonFromZipURL",
        "parameters": [
          " * url - URL of the zip file to install."
        ],
        "returns": [
          " * `true` if the installation was successful, `nil` otherwise"
        ],
        "signature": "SpoonInstall:installSpoonFromZipURL(url)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "SpoonInstall:repolist()",
        "desc": "Return a sorted list of registered Spoon repositories",
        "doc": "Return a sorted list of registered Spoon repositories\n\nParameters:\n * None\n\nReturns:\n * Table containing a list of strings with the repository identifiers",
        "name": "repolist",
        "parameters": [
          " * None"
        ],
        "returns": [
          " * Table containing a list of strings with the repository identifiers"
        ],
        "signature": "SpoonInstall:repolist()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "SpoonInstall:search(pat)",
        "desc": "Search repositories for a pattern",
        "doc": "Search repositories for a pattern\n\nParameters:\n * pat - Lua pattern that will be matched against the name and description of each spoon in the registered repositories. All text is converted to lowercase before searching it, so you can use all-lowercase in your pattern.\n\nReturns:\n * Table containing a list of matching entries. Each entry is a table with the following keys:\n   * name - Spoon name\n   * desc - description of the spoon\n   * repo - identifier in the repository where the match was found",
        "name": "search",
        "parameters": [
          " * pat - Lua pattern that will be matched against the name and description of each spoon in the registered repositories. All text is converted to lowercase before searching it, so you can use all-lowercase in your pattern."
        ],
        "returns": [
          " * Table containing a list of matching entries. Each entry is a table with the following keys:",
          "   * name - Spoon name",
          "   * desc - description of the spoon",
          "   * repo - identifier in the repository where the match was found"
        ],
        "signature": "SpoonInstall:search(pat)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "SpoonInstall:updateAllRepos()",
        "desc": "Synchronously fetch the information about the contents of all Spoon repositories registered in `SpoonInstall.repos`",
        "doc": "Synchronously fetch the information about the contents of all Spoon repositories registered in `SpoonInstall.repos`\n\nParameters:\n * None\n\nReturns:\n * None\n\nNotes:\n * This is a synchronous call, which means Hammerspoon will be blocked until it finishes.\n * For now, the repository data is not persisted, so you need to update it after every restart if you want to use any of the install functions.",
        "name": "updateAllRepos",
        "notes": [
          " * This is a synchronous call, which means Hammerspoon will be blocked until it finishes.",
          " * For now, the repository data is not persisted, so you need to update it after every restart if you want to use any of the install functions."
        ],
        "parameters": [
          " * None"
        ],
        "returns": [
          " * None"
        ],
        "signature": "SpoonInstall:updateAllRepos()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "SpoonInstall:updateRepo(repo)",
        "desc": "Synchronously fetch the information about the contents of a Spoon repository",
        "doc": "Synchronously fetch the information about the contents of a Spoon repository\n\nParameters:\n * repo - name of the repository to update. Defaults to `\"default\"`.\n\nReturns:\n * `true` if the update was successful, `nil` otherwise\n\nNotes:\n * This is a synchronous call, which means Hammerspoon will be blocked until it finishes. For use in your configuration files, it's advisable to use `SpoonInstall.asyncUpdateRepo()` instead.\n * For now, the repository data is not persisted, so you need to update it after every restart if you want to use any of the install functions.",
        "name": "updateRepo",
        "notes": [
          " * This is a synchronous call, which means Hammerspoon will be blocked until it finishes. For use in your configuration files, it's advisable to use `SpoonInstall.asyncUpdateRepo()` instead.",
          " * For now, the repository data is not persisted, so you need to update it after every restart if you want to use any of the install functions."
        ],
        "parameters": [
          " * repo - name of the repository to update. Defaults to `\"default\"`."
        ],
        "returns": [
          " * `true` if the update was successful, `nil` otherwise"
        ],
        "signature": "SpoonInstall:updateRepo(repo)",
        "stripped_doc": "",
        "type": "Method"
      }
    ],
    "Variable": [
      {
        "def": "SpoonInstall.logger",
        "desc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "doc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "name": "logger",
        "signature": "SpoonInstall.logger",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "SpoonInstall.repos",
        "desc": "Table containing the list of available Spoon repositories. The key",
        "doc": "Table containing the list of available Spoon repositories. The key\nof each entry is an identifier for the repository, and its value\nis a table with the following entries:\n * desc - Human-readable description for the repository\n * url - Base URL for the repository. For now the repository is assumed to be hosted in GitHub, and the URL should be the main base URL of the repository. Repository metadata needs to be stored under `docs/docs.json`, and the Spoon zip files need to be stored under `Spoons/`.\n\nDefault value:\n```\n{\n   default = {\n      url = \"https://github.com/Hammerspoon/Spoons\",\n      desc = \"Main Hammerspoon Spoon repository\",\n   }\n}\n```",
        "name": "repos",
        "signature": "SpoonInstall.repos",
        "stripped_doc": "of each entry is an identifier for the repository, and its value\nis a table with the following entries:\n * desc - Human-readable description for the repository\n * url - Base URL for the repository. For now the repository is assumed to be hosted in GitHub, and the URL should be the main base URL of the repository. Repository metadata needs to be stored under `docs/docs.json`, and the Spoon zip files need to be stored under `Spoons/`.\nDefault value:\n```\n{\n   default = {\n      url = \"https://github.com/Hammerspoon/Spoons\",\n      desc = \"Main Hammerspoon Spoon repository\",\n   }\n}\n```",
        "type": "Variable"
      },
      {
        "def": "SpoonInstall.use_syncinstall",
        "desc": "If `true`, `andUse()` will update repos and install packages synchronously. Defaults to `false`.",
        "doc": "If `true`, `andUse()` will update repos and install packages synchronously. Defaults to `false`.\n\nKeep in mind that if you set this to `true`, Hammerspoon will\nblock until all missing Spoons are installed, but the notifications\nwill happen at a more \"human readable\" rate.",
        "name": "use_syncinstall",
        "signature": "SpoonInstall.use_syncinstall",
        "stripped_doc": "Keep in mind that if you set this to `true`, Hammerspoon will\nblock until all missing Spoons are installed, but the notifications\nwill happen at a more \"human readable\" rate.",
        "type": "Variable"
      }
    ],
    "desc": "Install and manage Spoons and Spoon repositories",
    "doc": "Install and manage Spoons and Spoon repositories\n\nDownload: [https://github.com/Hammerspoon/Spoons/raw/master/Spoons/SpoonInstall.spoon.zip](https://github.com/Hammerspoon/Spoons/raw/master/Spoons/SpoonInstall.spoon.zip)",
    "items": [
      {
        "def": "SpoonInstall:andUse(name, arg)",
        "desc": "Declaratively install, load and configure a Spoon",
        "doc": "Declaratively install, load and configure a Spoon\n\nParameters:\n * name - the name of the Spoon to install (without the `.spoon` extension). If the Spoon is already installed, it will be loaded using `hs.loadSpoon()`. If it is not installed, it will be installed using `SpoonInstall:asyncInstallSpoonFromRepo()` and then loaded.\n * arg - if provided, can be used to specify the configuration of the Spoon. The following keys are recognized (all are optional):\n   * repo - repository from where the Spoon should be installed if not present in the system, as defined in `SpoonInstall.repos`. Defaults to `\"default\"`.\n   * config - a table containing variables to be stored in the Spoon object to configure it. For example, `config = { answer = 42 }` will result in `spoon.<LoadedSpoon>.answer` being set to 42.\n   * hotkeys - a table containing hotkey bindings. If provided, will be passed as-is to the Spoon's `bindHotkeys()` method. The special string `\"default\"` can be given to use the Spoons `defaultHotkeys` variable, if it exists.\n   * fn - a function which will be called with the freshly-loaded Spoon object as its first argument.\n   * loglevel - if the Spoon has a variable called `logger`, its `setLogLevel()` method will be called with this value.\n   * start - if `true`, call the Spoon's `start()` method after configuring everything else.\n   * disable - if `true`, do nothing. Easier than commenting it out when you want to temporarily disable a spoon.\n\nReturns:\n * None",
        "name": "andUse",
        "parameters": [
          " * name - the name of the Spoon to install (without the `.spoon` extension). If the Spoon is already installed, it will be loaded using `hs.loadSpoon()`. If it is not installed, it will be installed using `SpoonInstall:asyncInstallSpoonFromRepo()` and then loaded.",
          " * arg - if provided, can be used to specify the configuration of the Spoon. The following keys are recognized (all are optional):",
          "   * repo - repository from where the Spoon should be installed if not present in the system, as defined in `SpoonInstall.repos`. Defaults to `\"default\"`.",
          "   * config - a table containing variables to be stored in the Spoon object to configure it. For example, `config = { answer = 42 }` will result in `spoon.<LoadedSpoon>.answer` being set to 42.",
          "   * hotkeys - a table containing hotkey bindings. If provided, will be passed as-is to the Spoon's `bindHotkeys()` method. The special string `\"default\"` can be given to use the Spoons `defaultHotkeys` variable, if it exists.",
          "   * fn - a function which will be called with the freshly-loaded Spoon object as its first argument.",
          "   * loglevel - if the Spoon has a variable called `logger`, its `setLogLevel()` method will be called with this value.",
          "   * start - if `true`, call the Spoon's `start()` method after configuring everything else.",
          "   * disable - if `true`, do nothing. Easier than commenting it out when you want to temporarily disable a spoon."
        ],
        "returns": [
          " * None"
        ],
        "signature": "SpoonInstall:andUse(name, arg)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "SpoonInstall:asyncInstallSpoonFromRepo(name, repo, callback)",
        "desc": "Asynchronously install a Spoon from a registered repository",
        "doc": "Asynchronously install a Spoon from a registered repository\n\nParameters:\n * name - Name of the Spoon to install.\n * repo - Name of the repository to use. Defaults to `\"default\"`\n * callback - if given, a function to call after the installation finishes (also if it fails). The function receives the following arguments:\n   * urlparts - Result of calling `hs.http.urlParts` on the URL of the Spoon zip file\n   * success - boolean indicating whether the installation was successful\n\nReturns:\n * `true` if the installation was correctly initiated (i.e. the repo and spoon name were correct), `false` otherwise.",
        "name": "asyncInstallSpoonFromRepo",
        "parameters": [
          " * name - Name of the Spoon to install.",
          " * repo - Name of the repository to use. Defaults to `\"default\"`",
          " * callback - if given, a function to call after the installation finishes (also if it fails). The function receives the following arguments:",
          "   * urlparts - Result of calling `hs.http.urlParts` on the URL of the Spoon zip file",
          "   * success - boolean indicating whether the installation was successful"
        ],
        "returns": [
          " * `true` if the installation was correctly initiated (i.e. the repo and spoon name were correct), `false` otherwise."
        ],
        "signature": "SpoonInstall:asyncInstallSpoonFromRepo(name, repo, callback)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "SpoonInstall:asyncInstallSpoonFromZipURL(url, callback)",
        "desc": "Asynchronously download a Spoon zip file and install it.",
        "doc": "Asynchronously download a Spoon zip file and install it.\n\nParameters:\n * url - URL of the zip file to install.\n * callback - if given, a function to call after the installation finishes (also if it fails). The function receives the following arguments:\n   * urlparts - Result of calling `hs.http.urlParts` on the URL of the Spoon zip file\n   * success - boolean indicating whether the installation was successful\n\nReturns:\n * `true` if the installation was correctly initiated (i.e. the URL is valid), `false` otherwise",
        "name": "asyncInstallSpoonFromZipURL",
        "parameters": [
          " * url - URL of the zip file to install.",
          " * callback - if given, a function to call after the installation finishes (also if it fails). The function receives the following arguments:",
          "   * urlparts - Result of calling `hs.http.urlParts` on the URL of the Spoon zip file",
          "   * success - boolean indicating whether the installation was successful"
        ],
        "returns": [
          " * `true` if the installation was correctly initiated (i.e. the URL is valid), `false` otherwise"
        ],
        "signature": "SpoonInstall:asyncInstallSpoonFromZipURL(url, callback)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "SpoonInstall:asyncUpdateRepo(repo, callback)",
        "desc": "Asynchronously fetch the information about the contents of a Spoon repository",
        "doc": "Asynchronously fetch the information about the contents of a Spoon repository\n\nParameters:\n * repo - name of the repository to update. Defaults to `\"default\"`.\n * callback - if given, a function to be called after the update finishes (also if it fails). The function will receive the following arguments:\n   * repo - name of the repository\n   * success - boolean indicating whether the update succeeded\n\nReturns:\n * `true` if the update was correctly initiated (i.e. the repo name is valid), `nil` otherwise\n\nNotes:\n * For now, the repository data is not persisted, so you need to update it after every restart if you want to use any of the install functions.",
        "name": "asyncUpdateRepo",
        "notes": [
          " * For now, the repository data is not persisted, so you need to update it after every restart if you want to use any of the install functions."
        ],
        "parameters": [
          " * repo - name of the repository to update. Defaults to `\"default\"`.",
          " * callback - if given, a function to be called after the update finishes (also if it fails). The function will receive the following arguments:",
          "   * repo - name of the repository",
          "   * success - boolean indicating whether the update succeeded"
        ],
        "returns": [
          " * `true` if the update was correctly initiated (i.e. the repo name is valid), `nil` otherwise"
        ],
        "signature": "SpoonInstall:asyncUpdateRepo(repo, callback)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "SpoonInstall:installSpoonFromRepo(name, repo)",
        "desc": "Synchronously install a Spoon from a registered repository",
        "doc": "Synchronously install a Spoon from a registered repository\n\nParameters:\n * name = Name of the Spoon to install.\n * repo - Name of the repository to use. Defaults to `\"default\"`\n\nReturns:\n * `true` if the installation was successful, `nil` otherwise.",
        "name": "installSpoonFromRepo",
        "parameters": [
          " * name = Name of the Spoon to install.",
          " * repo - Name of the repository to use. Defaults to `\"default\"`"
        ],
        "returns": [
          " * `true` if the installation was successful, `nil` otherwise."
        ],
        "signature": "SpoonInstall:installSpoonFromRepo(name, repo)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "SpoonInstall:installSpoonFromZipURL(url)",
        "desc": "Synchronously download a Spoon zip file and install it.",
        "doc": "Synchronously download a Spoon zip file and install it.\n\nParameters:\n * url - URL of the zip file to install.\n\nReturns:\n * `true` if the installation was successful, `nil` otherwise",
        "name": "installSpoonFromZipURL",
        "parameters": [
          " * url - URL of the zip file to install."
        ],
        "returns": [
          " * `true` if the installation was successful, `nil` otherwise"
        ],
        "signature": "SpoonInstall:installSpoonFromZipURL(url)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "SpoonInstall.logger",
        "desc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "doc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "name": "logger",
        "signature": "SpoonInstall.logger",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "SpoonInstall:repolist()",
        "desc": "Return a sorted list of registered Spoon repositories",
        "doc": "Return a sorted list of registered Spoon repositories\n\nParameters:\n * None\n\nReturns:\n * Table containing a list of strings with the repository identifiers",
        "name": "repolist",
        "parameters": [
          " * None"
        ],
        "returns": [
          " * Table containing a list of strings with the repository identifiers"
        ],
        "signature": "SpoonInstall:repolist()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "SpoonInstall.repos",
        "desc": "Table containing the list of available Spoon repositories. The key",
        "doc": "Table containing the list of available Spoon repositories. The key\nof each entry is an identifier for the repository, and its value\nis a table with the following entries:\n * desc - Human-readable description for the repository\n * url - Base URL for the repository. For now the repository is assumed to be hosted in GitHub, and the URL should be the main base URL of the repository. Repository metadata needs to be stored under `docs/docs.json`, and the Spoon zip files need to be stored under `Spoons/`.\n\nDefault value:\n```\n{\n   default = {\n      url = \"https://github.com/Hammerspoon/Spoons\",\n      desc = \"Main Hammerspoon Spoon repository\",\n   }\n}\n```",
        "name": "repos",
        "signature": "SpoonInstall.repos",
        "stripped_doc": "of each entry is an identifier for the repository, and its value\nis a table with the following entries:\n * desc - Human-readable description for the repository\n * url - Base URL for the repository. For now the repository is assumed to be hosted in GitHub, and the URL should be the main base URL of the repository. Repository metadata needs to be stored under `docs/docs.json`, and the Spoon zip files need to be stored under `Spoons/`.\nDefault value:\n```\n{\n   default = {\n      url = \"https://github.com/Hammerspoon/Spoons\",\n      desc = \"Main Hammerspoon Spoon repository\",\n   }\n}\n```",
        "type": "Variable"
      },
      {
        "def": "SpoonInstall:search(pat)",
        "desc": "Search repositories for a pattern",
        "doc": "Search repositories for a pattern\n\nParameters:\n * pat - Lua pattern that will be matched against the name and description of each spoon in the registered repositories. All text is converted to lowercase before searching it, so you can use all-lowercase in your pattern.\n\nReturns:\n * Table containing a list of matching entries. Each entry is a table with the following keys:\n   * name - Spoon name\n   * desc - description of the spoon\n   * repo - identifier in the repository where the match was found",
        "name": "search",
        "parameters": [
          " * pat - Lua pattern that will be matched against the name and description of each spoon in the registered repositories. All text is converted to lowercase before searching it, so you can use all-lowercase in your pattern."
        ],
        "returns": [
          " * Table containing a list of matching entries. Each entry is a table with the following keys:",
          "   * name - Spoon name",
          "   * desc - description of the spoon",
          "   * repo - identifier in the repository where the match was found"
        ],
        "signature": "SpoonInstall:search(pat)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "SpoonInstall:updateAllRepos()",
        "desc": "Synchronously fetch the information about the contents of all Spoon repositories registered in `SpoonInstall.repos`",
        "doc": "Synchronously fetch the information about the contents of all Spoon repositories registered in `SpoonInstall.repos`\n\nParameters:\n * None\n\nReturns:\n * None\n\nNotes:\n * This is a synchronous call, which means Hammerspoon will be blocked until it finishes.\n * For now, the repository data is not persisted, so you need to update it after every restart if you want to use any of the install functions.",
        "name": "updateAllRepos",
        "notes": [
          " * This is a synchronous call, which means Hammerspoon will be blocked until it finishes.",
          " * For now, the repository data is not persisted, so you need to update it after every restart if you want to use any of the install functions."
        ],
        "parameters": [
          " * None"
        ],
        "returns": [
          " * None"
        ],
        "signature": "SpoonInstall:updateAllRepos()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "SpoonInstall:updateRepo(repo)",
        "desc": "Synchronously fetch the information about the contents of a Spoon repository",
        "doc": "Synchronously fetch the information about the contents of a Spoon repository\n\nParameters:\n * repo - name of the repository to update. Defaults to `\"default\"`.\n\nReturns:\n * `true` if the update was successful, `nil` otherwise\n\nNotes:\n * This is a synchronous call, which means Hammerspoon will be blocked until it finishes. For use in your configuration files, it's advisable to use `SpoonInstall.asyncUpdateRepo()` instead.\n * For now, the repository data is not persisted, so you need to update it after every restart if you want to use any of the install functions.",
        "name": "updateRepo",
        "notes": [
          " * This is a synchronous call, which means Hammerspoon will be blocked until it finishes. For use in your configuration files, it's advisable to use `SpoonInstall.asyncUpdateRepo()` instead.",
          " * For now, the repository data is not persisted, so you need to update it after every restart if you want to use any of the install functions."
        ],
        "parameters": [
          " * repo - name of the repository to update. Defaults to `\"default\"`."
        ],
        "returns": [
          " * `true` if the update was successful, `nil` otherwise"
        ],
        "signature": "SpoonInstall:updateRepo(repo)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "SpoonInstall.use_syncinstall",
        "desc": "If `true`, `andUse()` will update repos and install packages synchronously. Defaults to `false`.",
        "doc": "If `true`, `andUse()` will update repos and install packages synchronously. Defaults to `false`.\n\nKeep in mind that if you set this to `true`, Hammerspoon will\nblock until all missing Spoons are installed, but the notifications\nwill happen at a more \"human readable\" rate.",
        "name": "use_syncinstall",
        "signature": "SpoonInstall.use_syncinstall",
        "stripped_doc": "Keep in mind that if you set this to `true`, Hammerspoon will\nblock until all missing Spoons are installed, but the notifications\nwill happen at a more \"human readable\" rate.",
        "type": "Variable"
      }
    ],
    "name": "SpoonInstall",
    "stripped_doc": "\nDownload: [https://github.com/Hammerspoon/Spoons/raw/master/Spoons/SpoonInstall.spoon.zip](https://github.com/Hammerspoon/Spoons/raw/master/Spoons/SpoonInstall.spoon.zip)",
    "submodules": [],
    "type": "Module"
  },
  {
    "Command": [],
    "Constant": [],
    "Constructor": [],
    "Deprecated": [],
    "Field": [],
    "Function": [],
    "Method": [
      {
        "def": "TextClipboardHistory:bindHotkeys(mapping)",
        "desc": "Binds hotkeys for TextClipboardHistory",
        "doc": "Binds hotkeys for TextClipboardHistory\n\nParameters:\n * mapping - A table containing hotkey objifier/key details for the following items:\n  * show_clipboard - Display the clipboard history chooser\n  * toggle_clipboard - Show/hide the clipboard history chooser",
        "name": "bindHotkeys",
        "parameters": [
          " * mapping - A table containing hotkey objifier/key details for the following items:",
          "  * show_clipboard - Display the clipboard history chooser",
          "  * toggle_clipboard - Show/hide the clipboard history chooser"
        ],
        "signature": "TextClipboardHistory:bindHotkeys(mapping)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "TextClipboardHistory:checkAndStorePasteboard()",
        "desc": "If the pasteboard has changed, we add the current item to our history and update the counter",
        "doc": "If the pasteboard has changed, we add the current item to our history and update the counter",
        "name": "checkAndStorePasteboard",
        "signature": "TextClipboardHistory:checkAndStorePasteboard()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "TextClipboardHistory:clearAll()",
        "desc": "Clears the clipboard and history",
        "doc": "Clears the clipboard and history",
        "name": "clearAll",
        "signature": "TextClipboardHistory:clearAll()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "TextClipboardHistory:clearLastItem()",
        "desc": "Clears the last added to the history",
        "doc": "Clears the last added to the history",
        "name": "clearLastItem",
        "signature": "TextClipboardHistory:clearLastItem()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "TextClipboardHistory:pasteboardToClipboard(item)",
        "desc": "Add the given string to the history",
        "doc": "Add the given string to the history\n\nParameters:\n * item - string to add to the clipboard history\n\nReturns:\n * None",
        "name": "pasteboardToClipboard",
        "parameters": [
          " * item - string to add to the clipboard history"
        ],
        "returns": [
          " * None"
        ],
        "signature": "TextClipboardHistory:pasteboardToClipboard(item)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "TextClipboardHistory:shouldBeStored()",
        "desc": "Verify whether the pasteboard contents matches one of the values in `TextClipboardHistory.ignoredIdentifiers`",
        "doc": "Verify whether the pasteboard contents matches one of the values in `TextClipboardHistory.ignoredIdentifiers`",
        "name": "shouldBeStored",
        "signature": "TextClipboardHistory:shouldBeStored()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "TextClipboardHistory:showClipboard()",
        "desc": "Display the current clipboard list in a chooser",
        "doc": "Display the current clipboard list in a chooser",
        "name": "showClipboard",
        "signature": "TextClipboardHistory:showClipboard()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "TextClipboardHistory:start()",
        "desc": "Start the clipboard history collector",
        "doc": "Start the clipboard history collector",
        "name": "start",
        "signature": "TextClipboardHistory:start()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "TextClipboardHistory:toggleClipboard()",
        "desc": "Show/hide the clipboard list, depending on its current state",
        "doc": "Show/hide the clipboard list, depending on its current state",
        "name": "toggleClipboard",
        "signature": "TextClipboardHistory:toggleClipboard()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "TextClipboardHistory:togglePasteOnSelect()",
        "desc": "Toggle the value of `TextClipboardHistory.paste_on_select`",
        "doc": "Toggle the value of `TextClipboardHistory.paste_on_select`",
        "name": "togglePasteOnSelect",
        "signature": "TextClipboardHistory:togglePasteOnSelect()",
        "stripped_doc": "",
        "type": "Method"
      }
    ],
    "Variable": [
      {
        "def": "TextClipboardHistory.deduplicate",
        "desc": "Whether to remove duplicates from the list, keeping only the latest one. Defaults to `true`.",
        "doc": "Whether to remove duplicates from the list, keeping only the latest one. Defaults to `true`.",
        "name": "deduplicate",
        "signature": "TextClipboardHistory.deduplicate",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "TextClipboardHistory.frequency",
        "desc": "Speed in seconds to check for clipboard changes. If you check too frequently, you will degrade performance, if you check sparsely you will loose copies. Defaults to 0.8.",
        "doc": "Speed in seconds to check for clipboard changes. If you check too frequently, you will degrade performance, if you check sparsely you will loose copies. Defaults to 0.8.",
        "name": "frequency",
        "signature": "TextClipboardHistory.frequency",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "TextClipboardHistory.hist_size",
        "desc": "How many items to keep on history. Defaults to 100",
        "doc": "How many items to keep on history. Defaults to 100",
        "name": "hist_size",
        "signature": "TextClipboardHistory.hist_size",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "TextClipboardHistory.honor_ignoredidentifiers",
        "desc": "If `true`, check the data identifiers set in the pasteboard and ignore entries which match those listed in `TextClipboardHistory.ignoredIdentifiers`. The list of identifiers comes from http://nspasteboard.org. Defaults to `true`",
        "doc": "If `true`, check the data identifiers set in the pasteboard and ignore entries which match those listed in `TextClipboardHistory.ignoredIdentifiers`. The list of identifiers comes from http://nspasteboard.org. Defaults to `true`",
        "name": "honor_ignoredidentifiers",
        "signature": "TextClipboardHistory.honor_ignoredidentifiers",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "TextClipboardHistory.ignoredIdentifiers",
        "desc": "Types of clipboard entries to ignore, see http://nspasteboard.org. Code from https://github.com/asmagill/hammerspoon-config/blob/master/utils/_menus/newClipper.lua. Default value (don't modify unless you know what you are doing):",
        "doc": "Types of clipboard entries to ignore, see http://nspasteboard.org. Code from https://github.com/asmagill/hammerspoon-config/blob/master/utils/_menus/newClipper.lua. Default value (don't modify unless you know what you are doing):\n```\n {\n    [\"de.petermaurer.TransientPasteboardType\"] = true, -- Transient : Textpander, TextExpander, Butler\n    [\"com.typeit4me.clipping\"]                 = true, -- Transient : TypeIt4Me\n    [\"Pasteboard generator type\"]              = true, -- Transient : Typinator\n    [\"com.agilebits.onepassword\"]              = true, -- Confidential : 1Password\n    [\"org.nspasteboard.TransientType\"]         = true, -- Universal, Transient\n    [\"org.nspasteboard.ConcealedType\"]         = true, -- Universal, Concealed\n    [\"org.nspasteboard.AutoGeneratedType\"]     = true, -- Universal, Automatic\n }\n```",
        "name": "ignoredIdentifiers",
        "signature": "TextClipboardHistory.ignoredIdentifiers",
        "stripped_doc": "```\n {\n    [\"de.petermaurer.TransientPasteboardType\"] = true, -- Transient : Textpander, TextExpander, Butler\n    [\"com.typeit4me.clipping\"]                 = true, -- Transient : TypeIt4Me\n    [\"Pasteboard generator type\"]              = true, -- Transient : Typinator\n    [\"com.agilebits.onepassword\"]              = true, -- Confidential : 1Password\n    [\"org.nspasteboard.TransientType\"]         = true, -- Universal, Transient\n    [\"org.nspasteboard.ConcealedType\"]         = true, -- Universal, Concealed\n    [\"org.nspasteboard.AutoGeneratedType\"]     = true, -- Universal, Automatic\n }\n```",
        "type": "Variable"
      },
      {
        "def": "TextClipboardHistory.logger",
        "desc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "doc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "name": "logger",
        "signature": "TextClipboardHistory.logger",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "TextClipboardHistory.menubar_title",
        "desc": "String to show in the menubar if `TextClipboardHistory.show_in_menubar` is `true`. Defaults to `\"\\u{1f4ce}\"`, which is the [Unicode paperclip character](https://codepoints.net/U+1F4CE)",
        "doc": "String to show in the menubar if `TextClipboardHistory.show_in_menubar` is `true`. Defaults to `\"\\u{1f4ce}\"`, which is the [Unicode paperclip character](https://codepoints.net/U+1F4CE)",
        "name": "menubar_title",
        "signature": "TextClipboardHistory.menubar_title",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "TextClipboardHistory.paste_on_select",
        "desc": "Whether to auto-type the item when selecting it from the menu. Can be toggled on the fly from the chooser. Defaults to `false`.",
        "doc": "Whether to auto-type the item when selecting it from the menu. Can be toggled on the fly from the chooser. Defaults to `false`.",
        "name": "paste_on_select",
        "signature": "TextClipboardHistory.paste_on_select",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "TextClipboardHistory.show_in_menubar",
        "desc": "Whether to show a menubar item to open the clipboard history. Defaults to `true`",
        "doc": "Whether to show a menubar item to open the clipboard history. Defaults to `true`",
        "name": "show_in_menubar",
        "signature": "TextClipboardHistory.show_in_menubar",
        "stripped_doc": "",
        "type": "Variable"
      }
    ],
    "desc": "Keep a history of the clipboard, only for text entries",
    "doc": "Keep a history of the clipboard, only for text entries\n\nOriginally based on [code by VFS](https://github.com/VFS/.hammerspoon/blob/master/tools/clipboard.lua), but with many changes and some contributions and inspiration from [asmagill](https://github.com/asmagill/hammerspoon-config/blob/master/utils/_menus/newClipper.lua).\n\nDownload: [https://github.com/Hammerspoon/Spoons/raw/master/Spoons/TextClipboardHistory.spoon.zip](https://github.com/Hammerspoon/Spoons/raw/master/Spoons/TextClipboardHistory.spoon.zip)",
    "items": [
      {
        "def": "TextClipboardHistory:bindHotkeys(mapping)",
        "desc": "Binds hotkeys for TextClipboardHistory",
        "doc": "Binds hotkeys for TextClipboardHistory\n\nParameters:\n * mapping - A table containing hotkey objifier/key details for the following items:\n  * show_clipboard - Display the clipboard history chooser\n  * toggle_clipboard - Show/hide the clipboard history chooser",
        "name": "bindHotkeys",
        "parameters": [
          " * mapping - A table containing hotkey objifier/key details for the following items:",
          "  * show_clipboard - Display the clipboard history chooser",
          "  * toggle_clipboard - Show/hide the clipboard history chooser"
        ],
        "signature": "TextClipboardHistory:bindHotkeys(mapping)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "TextClipboardHistory:checkAndStorePasteboard()",
        "desc": "If the pasteboard has changed, we add the current item to our history and update the counter",
        "doc": "If the pasteboard has changed, we add the current item to our history and update the counter",
        "name": "checkAndStorePasteboard",
        "signature": "TextClipboardHistory:checkAndStorePasteboard()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "TextClipboardHistory:clearAll()",
        "desc": "Clears the clipboard and history",
        "doc": "Clears the clipboard and history",
        "name": "clearAll",
        "signature": "TextClipboardHistory:clearAll()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "TextClipboardHistory:clearLastItem()",
        "desc": "Clears the last added to the history",
        "doc": "Clears the last added to the history",
        "name": "clearLastItem",
        "signature": "TextClipboardHistory:clearLastItem()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "TextClipboardHistory.deduplicate",
        "desc": "Whether to remove duplicates from the list, keeping only the latest one. Defaults to `true`.",
        "doc": "Whether to remove duplicates from the list, keeping only the latest one. Defaults to `true`.",
        "name": "deduplicate",
        "signature": "TextClipboardHistory.deduplicate",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "TextClipboardHistory.frequency",
        "desc": "Speed in seconds to check for clipboard changes. If you check too frequently, you will degrade performance, if you check sparsely you will loose copies. Defaults to 0.8.",
        "doc": "Speed in seconds to check for clipboard changes. If you check too frequently, you will degrade performance, if you check sparsely you will loose copies. Defaults to 0.8.",
        "name": "frequency",
        "signature": "TextClipboardHistory.frequency",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "TextClipboardHistory.hist_size",
        "desc": "How many items to keep on history. Defaults to 100",
        "doc": "How many items to keep on history. Defaults to 100",
        "name": "hist_size",
        "signature": "TextClipboardHistory.hist_size",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "TextClipboardHistory.honor_ignoredidentifiers",
        "desc": "If `true`, check the data identifiers set in the pasteboard and ignore entries which match those listed in `TextClipboardHistory.ignoredIdentifiers`. The list of identifiers comes from http://nspasteboard.org. Defaults to `true`",
        "doc": "If `true`, check the data identifiers set in the pasteboard and ignore entries which match those listed in `TextClipboardHistory.ignoredIdentifiers`. The list of identifiers comes from http://nspasteboard.org. Defaults to `true`",
        "name": "honor_ignoredidentifiers",
        "signature": "TextClipboardHistory.honor_ignoredidentifiers",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "TextClipboardHistory.ignoredIdentifiers",
        "desc": "Types of clipboard entries to ignore, see http://nspasteboard.org. Code from https://github.com/asmagill/hammerspoon-config/blob/master/utils/_menus/newClipper.lua. Default value (don't modify unless you know what you are doing):",
        "doc": "Types of clipboard entries to ignore, see http://nspasteboard.org. Code from https://github.com/asmagill/hammerspoon-config/blob/master/utils/_menus/newClipper.lua. Default value (don't modify unless you know what you are doing):\n```\n {\n    [\"de.petermaurer.TransientPasteboardType\"] = true, -- Transient : Textpander, TextExpander, Butler\n    [\"com.typeit4me.clipping\"]                 = true, -- Transient : TypeIt4Me\n    [\"Pasteboard generator type\"]              = true, -- Transient : Typinator\n    [\"com.agilebits.onepassword\"]              = true, -- Confidential : 1Password\n    [\"org.nspasteboard.TransientType\"]         = true, -- Universal, Transient\n    [\"org.nspasteboard.ConcealedType\"]         = true, -- Universal, Concealed\n    [\"org.nspasteboard.AutoGeneratedType\"]     = true, -- Universal, Automatic\n }\n```",
        "name": "ignoredIdentifiers",
        "signature": "TextClipboardHistory.ignoredIdentifiers",
        "stripped_doc": "```\n {\n    [\"de.petermaurer.TransientPasteboardType\"] = true, -- Transient : Textpander, TextExpander, Butler\n    [\"com.typeit4me.clipping\"]                 = true, -- Transient : TypeIt4Me\n    [\"Pasteboard generator type\"]              = true, -- Transient : Typinator\n    [\"com.agilebits.onepassword\"]              = true, -- Confidential : 1Password\n    [\"org.nspasteboard.TransientType\"]         = true, -- Universal, Transient\n    [\"org.nspasteboard.ConcealedType\"]         = true, -- Universal, Concealed\n    [\"org.nspasteboard.AutoGeneratedType\"]     = true, -- Universal, Automatic\n }\n```",
        "type": "Variable"
      },
      {
        "def": "TextClipboardHistory.logger",
        "desc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "doc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "name": "logger",
        "signature": "TextClipboardHistory.logger",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "TextClipboardHistory.menubar_title",
        "desc": "String to show in the menubar if `TextClipboardHistory.show_in_menubar` is `true`. Defaults to `\"\\u{1f4ce}\"`, which is the [Unicode paperclip character](https://codepoints.net/U+1F4CE)",
        "doc": "String to show in the menubar if `TextClipboardHistory.show_in_menubar` is `true`. Defaults to `\"\\u{1f4ce}\"`, which is the [Unicode paperclip character](https://codepoints.net/U+1F4CE)",
        "name": "menubar_title",
        "signature": "TextClipboardHistory.menubar_title",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "TextClipboardHistory.paste_on_select",
        "desc": "Whether to auto-type the item when selecting it from the menu. Can be toggled on the fly from the chooser. Defaults to `false`.",
        "doc": "Whether to auto-type the item when selecting it from the menu. Can be toggled on the fly from the chooser. Defaults to `false`.",
        "name": "paste_on_select",
        "signature": "TextClipboardHistory.paste_on_select",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "TextClipboardHistory:pasteboardToClipboard(item)",
        "desc": "Add the given string to the history",
        "doc": "Add the given string to the history\n\nParameters:\n * item - string to add to the clipboard history\n\nReturns:\n * None",
        "name": "pasteboardToClipboard",
        "parameters": [
          " * item - string to add to the clipboard history"
        ],
        "returns": [
          " * None"
        ],
        "signature": "TextClipboardHistory:pasteboardToClipboard(item)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "TextClipboardHistory:shouldBeStored()",
        "desc": "Verify whether the pasteboard contents matches one of the values in `TextClipboardHistory.ignoredIdentifiers`",
        "doc": "Verify whether the pasteboard contents matches one of the values in `TextClipboardHistory.ignoredIdentifiers`",
        "name": "shouldBeStored",
        "signature": "TextClipboardHistory:shouldBeStored()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "TextClipboardHistory.show_in_menubar",
        "desc": "Whether to show a menubar item to open the clipboard history. Defaults to `true`",
        "doc": "Whether to show a menubar item to open the clipboard history. Defaults to `true`",
        "name": "show_in_menubar",
        "signature": "TextClipboardHistory.show_in_menubar",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "TextClipboardHistory:showClipboard()",
        "desc": "Display the current clipboard list in a chooser",
        "doc": "Display the current clipboard list in a chooser",
        "name": "showClipboard",
        "signature": "TextClipboardHistory:showClipboard()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "TextClipboardHistory:start()",
        "desc": "Start the clipboard history collector",
        "doc": "Start the clipboard history collector",
        "name": "start",
        "signature": "TextClipboardHistory:start()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "TextClipboardHistory:toggleClipboard()",
        "desc": "Show/hide the clipboard list, depending on its current state",
        "doc": "Show/hide the clipboard list, depending on its current state",
        "name": "toggleClipboard",
        "signature": "TextClipboardHistory:toggleClipboard()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "TextClipboardHistory:togglePasteOnSelect()",
        "desc": "Toggle the value of `TextClipboardHistory.paste_on_select`",
        "doc": "Toggle the value of `TextClipboardHistory.paste_on_select`",
        "name": "togglePasteOnSelect",
        "signature": "TextClipboardHistory:togglePasteOnSelect()",
        "stripped_doc": "",
        "type": "Method"
      }
    ],
    "name": "TextClipboardHistory",
    "stripped_doc": "\nOriginally based on [code by VFS](https://github.com/VFS/.hammerspoon/blob/master/tools/clipboard.lua), but with many changes and some contributions and inspiration from [asmagill](https://github.com/asmagill/hammerspoon-config/blob/master/utils/_menus/newClipper.lua).\n\nDownload: [https://github.com/Hammerspoon/Spoons/raw/master/Spoons/TextClipboardHistory.spoon.zip](https://github.com/Hammerspoon/Spoons/raw/master/Spoons/TextClipboardHistory.spoon.zip)",
    "submodules": [],
    "type": "Module"
  },
  {
    "Command": [],
    "Constant": [],
    "Constructor": [],
    "Deprecated": [],
    "Field": [],
    "Function": [],
    "Method": [
      {
        "def": "ToggleSkypeMute:bindHotkeys(mapping)",
        "desc": "Binds hotkeys for ToggleSkypeMute",
        "doc": "Binds hotkeys for ToggleSkypeMute\n\nParameters:\n * mapping - A table containing hotkey modifier/key details for the following items:\n  * toggle_skype - Mute/unmute active conversation in Skype\n  * toggle_skype_for_business - Mute/unmute active conversation in Skype For Business",
        "name": "bindHotkeys",
        "parameters": [
          " * mapping - A table containing hotkey modifier/key details for the following items:",
          "  * toggle_skype - Mute/unmute active conversation in Skype",
          "  * toggle_skype_for_business - Mute/unmute active conversation in Skype For Business"
        ],
        "signature": "ToggleSkypeMute:bindHotkeys(mapping)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "ToggleSkypeMute:toggle(app)",
        "desc": "Toggle Skype between muted/unmuted, whether it is focused or not",
        "doc": "Toggle Skype between muted/unmuted, whether it is focused or not\n\nParameters:\n * app - name of the application to mute/unmute. Supported values are \"Skype\" and \"Skype for Business\". Defaults to \"Skype\".\n\nReturns:\n * None",
        "name": "toggle",
        "parameters": [
          " * app - name of the application to mute/unmute. Supported values are \"Skype\" and \"Skype for Business\". Defaults to \"Skype\"."
        ],
        "returns": [
          " * None"
        ],
        "signature": "ToggleSkypeMute:toggle(app)",
        "stripped_doc": "",
        "type": "Method"
      }
    ],
    "Variable": [
      {
        "def": "ToggleSkypeMute.logger",
        "desc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "doc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "name": "logger",
        "signature": "ToggleSkypeMute.logger",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "ToggleSkypeMute.notifications",
        "desc": "If `true`, produce notifications when Skype is muted/unmuted. Defaults to `true`.",
        "doc": "If `true`, produce notifications when Skype is muted/unmuted. Defaults to `true`.",
        "name": "notifications",
        "signature": "ToggleSkypeMute.notifications",
        "stripped_doc": "",
        "type": "Variable"
      }
    ],
    "desc": "Provide keybindings for muting/unmuting Skype or Skype for Business",
    "doc": "Provide keybindings for muting/unmuting Skype or Skype for Business\n\nDownload: [https://github.com/Hammerspoon/Spoons/raw/master/Spoons/ToggleSkypeMute.spoon.zip](https://github.com/Hammerspoon/Spoons/raw/master/Spoons/ToggleSkypeMute.spoon.zip)",
    "items": [
      {
        "def": "ToggleSkypeMute:bindHotkeys(mapping)",
        "desc": "Binds hotkeys for ToggleSkypeMute",
        "doc": "Binds hotkeys for ToggleSkypeMute\n\nParameters:\n * mapping - A table containing hotkey modifier/key details for the following items:\n  * toggle_skype - Mute/unmute active conversation in Skype\n  * toggle_skype_for_business - Mute/unmute active conversation in Skype For Business",
        "name": "bindHotkeys",
        "parameters": [
          " * mapping - A table containing hotkey modifier/key details for the following items:",
          "  * toggle_skype - Mute/unmute active conversation in Skype",
          "  * toggle_skype_for_business - Mute/unmute active conversation in Skype For Business"
        ],
        "signature": "ToggleSkypeMute:bindHotkeys(mapping)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "ToggleSkypeMute.logger",
        "desc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "doc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "name": "logger",
        "signature": "ToggleSkypeMute.logger",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "ToggleSkypeMute.notifications",
        "desc": "If `true`, produce notifications when Skype is muted/unmuted. Defaults to `true`.",
        "doc": "If `true`, produce notifications when Skype is muted/unmuted. Defaults to `true`.",
        "name": "notifications",
        "signature": "ToggleSkypeMute.notifications",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "ToggleSkypeMute:toggle(app)",
        "desc": "Toggle Skype between muted/unmuted, whether it is focused or not",
        "doc": "Toggle Skype between muted/unmuted, whether it is focused or not\n\nParameters:\n * app - name of the application to mute/unmute. Supported values are \"Skype\" and \"Skype for Business\". Defaults to \"Skype\".\n\nReturns:\n * None",
        "name": "toggle",
        "parameters": [
          " * app - name of the application to mute/unmute. Supported values are \"Skype\" and \"Skype for Business\". Defaults to \"Skype\"."
        ],
        "returns": [
          " * None"
        ],
        "signature": "ToggleSkypeMute:toggle(app)",
        "stripped_doc": "",
        "type": "Method"
      }
    ],
    "name": "ToggleSkypeMute",
    "stripped_doc": "\nDownload: [https://github.com/Hammerspoon/Spoons/raw/master/Spoons/ToggleSkypeMute.spoon.zip](https://github.com/Hammerspoon/Spoons/raw/master/Spoons/ToggleSkypeMute.spoon.zip)",
    "submodules": [],
    "type": "Module"
  },
  {
    "Command": [],
    "Constant": [],
    "Constructor": [],
    "Deprecated": [],
    "Field": [],
    "Function": [],
    "Method": [
      {
        "def": "WiFiTransitions:processTransition(new_ssid, prev_ssid, interface)",
        "desc": "Process the rules and execute any actions corresponding to the specified transition.",
        "doc": "Process the rules and execute any actions corresponding to the specified transition.\n\nThis method is called internally by the `hs.wifi.watcher` object\nwhen WiFi transitions happen. It does not get any system\ninformation nor does it set any Spoon state information, so it can\nalso be used to \"trigger\" transitions manually, either for testing\nor if the automated processing fails for any reason.\n\nParameters:\n * new_ssid - new SSID name\n * prev_ssid - previous SSID name. Defaults to `nil`\n * interface - interface where the transition occurred. Defaults to `nil`",
        "name": "processTransition",
        "parameters": [
          " * new_ssid - new SSID name",
          " * prev_ssid - previous SSID name. Defaults to `nil`",
          " * interface - interface where the transition occurred. Defaults to `nil`"
        ],
        "signature": "WiFiTransitions:processTransition(new_ssid, prev_ssid, interface)",
        "stripped_doc": "This method is called internally by the `hs.wifi.watcher` object\nwhen WiFi transitions happen. It does not get any system\ninformation nor does it set any Spoon state information, so it can\nalso be used to \"trigger\" transitions manually, either for testing\nor if the automated processing fails for any reason.",
        "type": "Method"
      },
      {
        "def": "WiFiTransitions:start()",
        "desc": "Start the WiFi watcher",
        "doc": "Start the WiFi watcher\n\nReturns:\n * The WiFiTransitions spoon object",
        "name": "start",
        "returns": [
          " * The WiFiTransitions spoon object"
        ],
        "signature": "WiFiTransitions:start()",
        "stripped_doc": "",
        "type": "Method"
      }
    ],
    "Variable": [
      {
        "def": "WiFiTransitions.actions",
        "desc": "Table containing a list of actions to execute for SSID transitions. Each action is itself a table with the following keys:",
        "doc": "Table containing a list of actions to execute for SSID transitions. Each action is itself a table with the following keys:\n * to - if given, pattern to match against the new SSID. Defaults to match any network. Transitions through the disabled state are ignored (i.e. normally a `nil` SSID is reported when switching SSIDs)\n * from - if given, pattern to match against the previous SSID. Defaults to match any network.\n * fn - function to execute if there is a match. Can also be a list of functions, which will be executed in sequence. Each function will receive the following arguments:\n   * event - always \"SSIDChange\"\n   * interface - name of the interface on which the SSID changed\n   * old_ssid - previous SSID name\n   * new_ssid - new SSID name\n * cmd - shell command to execute if there is a match. Can also be a list of commands, which will be executed in sequence using `hs.execute`. If `fn` is given, `cmd` is ignored.",
        "name": "actions",
        "signature": "WiFiTransitions.actions",
        "stripped_doc": " * to - if given, pattern to match against the new SSID. Defaults to match any network. Transitions through the disabled state are ignored (i.e. normally a `nil` SSID is reported when switching SSIDs)\n * from - if given, pattern to match against the previous SSID. Defaults to match any network.\n * fn - function to execute if there is a match. Can also be a list of functions, which will be executed in sequence. Each function will receive the following arguments:\n   * event - always \"SSIDChange\"\n   * interface - name of the interface on which the SSID changed\n   * old_ssid - previous SSID name\n   * new_ssid - new SSID name\n * cmd - shell command to execute if there is a match. Can also be a list of commands, which will be executed in sequence using `hs.execute`. If `fn` is given, `cmd` is ignored.",
        "type": "Variable"
      },
      {
        "def": "WiFiTransitions.logger",
        "desc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "doc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "name": "logger",
        "signature": "WiFiTransitions.logger",
        "stripped_doc": "",
        "type": "Variable"
      }
    ],
    "desc": "Allow arbitrary actions when transitioning between SSIDs",
    "doc": "Allow arbitrary actions when transitioning between SSIDs\n\nDownload: [https://github.com/Hammerspoon/Spoons/raw/master/Spoons/WiFiTransitions.spoon.zip](https://github.com/Hammerspoon/Spoons/raw/master/Spoons/WiFiTransitions.spoon.zip)",
    "items": [
      {
        "def": "WiFiTransitions.actions",
        "desc": "Table containing a list of actions to execute for SSID transitions. Each action is itself a table with the following keys:",
        "doc": "Table containing a list of actions to execute for SSID transitions. Each action is itself a table with the following keys:\n * to - if given, pattern to match against the new SSID. Defaults to match any network. Transitions through the disabled state are ignored (i.e. normally a `nil` SSID is reported when switching SSIDs)\n * from - if given, pattern to match against the previous SSID. Defaults to match any network.\n * fn - function to execute if there is a match. Can also be a list of functions, which will be executed in sequence. Each function will receive the following arguments:\n   * event - always \"SSIDChange\"\n   * interface - name of the interface on which the SSID changed\n   * old_ssid - previous SSID name\n   * new_ssid - new SSID name\n * cmd - shell command to execute if there is a match. Can also be a list of commands, which will be executed in sequence using `hs.execute`. If `fn` is given, `cmd` is ignored.",
        "name": "actions",
        "signature": "WiFiTransitions.actions",
        "stripped_doc": " * to - if given, pattern to match against the new SSID. Defaults to match any network. Transitions through the disabled state are ignored (i.e. normally a `nil` SSID is reported when switching SSIDs)\n * from - if given, pattern to match against the previous SSID. Defaults to match any network.\n * fn - function to execute if there is a match. Can also be a list of functions, which will be executed in sequence. Each function will receive the following arguments:\n   * event - always \"SSIDChange\"\n   * interface - name of the interface on which the SSID changed\n   * old_ssid - previous SSID name\n   * new_ssid - new SSID name\n * cmd - shell command to execute if there is a match. Can also be a list of commands, which will be executed in sequence using `hs.execute`. If `fn` is given, `cmd` is ignored.",
        "type": "Variable"
      },
      {
        "def": "WiFiTransitions.logger",
        "desc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "doc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "name": "logger",
        "signature": "WiFiTransitions.logger",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "WiFiTransitions:processTransition(new_ssid, prev_ssid, interface)",
        "desc": "Process the rules and execute any actions corresponding to the specified transition.",
        "doc": "Process the rules and execute any actions corresponding to the specified transition.\n\nThis method is called internally by the `hs.wifi.watcher` object\nwhen WiFi transitions happen. It does not get any system\ninformation nor does it set any Spoon state information, so it can\nalso be used to \"trigger\" transitions manually, either for testing\nor if the automated processing fails for any reason.\n\nParameters:\n * new_ssid - new SSID name\n * prev_ssid - previous SSID name. Defaults to `nil`\n * interface - interface where the transition occurred. Defaults to `nil`",
        "name": "processTransition",
        "parameters": [
          " * new_ssid - new SSID name",
          " * prev_ssid - previous SSID name. Defaults to `nil`",
          " * interface - interface where the transition occurred. Defaults to `nil`"
        ],
        "signature": "WiFiTransitions:processTransition(new_ssid, prev_ssid, interface)",
        "stripped_doc": "This method is called internally by the `hs.wifi.watcher` object\nwhen WiFi transitions happen. It does not get any system\ninformation nor does it set any Spoon state information, so it can\nalso be used to \"trigger\" transitions manually, either for testing\nor if the automated processing fails for any reason.",
        "type": "Method"
      },
      {
        "def": "WiFiTransitions:start()",
        "desc": "Start the WiFi watcher",
        "doc": "Start the WiFi watcher\n\nReturns:\n * The WiFiTransitions spoon object",
        "name": "start",
        "returns": [
          " * The WiFiTransitions spoon object"
        ],
        "signature": "WiFiTransitions:start()",
        "stripped_doc": "",
        "type": "Method"
      }
    ],
    "name": "WiFiTransitions",
    "stripped_doc": "\nDownload: [https://github.com/Hammerspoon/Spoons/raw/master/Spoons/WiFiTransitions.spoon.zip](https://github.com/Hammerspoon/Spoons/raw/master/Spoons/WiFiTransitions.spoon.zip)",
    "submodules": [],
    "type": "Module"
  },
  {
    "Command": [],
    "Constant": [],
    "Constructor": [],
    "Deprecated": [],
    "Field": [],
    "Function": [],
    "Method": [
      {
        "def": "WindowGrid:bindHotkeys(mapping)",
        "desc": "Binds hotkeys for WindowGrid",
        "doc": "Binds hotkeys for WindowGrid\n\nParameters:\n * mapping - A table containing hotkey objifier/key details for the following items:\n  * show_grid - show the grid overlay",
        "name": "bindHotkeys",
        "parameters": [
          " * mapping - A table containing hotkey objifier/key details for the following items:",
          "  * show_grid - show the grid overlay"
        ],
        "signature": "WindowGrid:bindHotkeys(mapping)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "WindowGrid:start()",
        "desc": "Sets the grid configuration according to `WindowGrid.gridGeometries`.",
        "doc": "Sets the grid configuration according to `WindowGrid.gridGeometries`.",
        "name": "start",
        "signature": "WindowGrid:start()",
        "stripped_doc": "",
        "type": "Method"
      }
    ],
    "Variable": [
      {
        "def": "WindowGrid.gridGeometries",
        "desc": "Table containing a list of arguments to be passed to grid.setGrid(). Each element in the table is itself a table with 1-3 arguments as defined for [hs.grid.setGrid()](http://www.hammerspoon.org/docs/hs.grid.html#setGrid). Defaults to an empty list, which results in the default 3x3 grid for all screen from `hs.grid`.",
        "doc": "Table containing a list of arguments to be passed to grid.setGrid(). Each element in the table is itself a table with 1-3 arguments as defined for [hs.grid.setGrid()](http://www.hammerspoon.org/docs/hs.grid.html#setGrid). Defaults to an empty list, which results in the default 3x3 grid for all screen from `hs.grid`.",
        "name": "gridGeometries",
        "signature": "WindowGrid.gridGeometries",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "WindowGrid.logger",
        "desc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "doc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "name": "logger",
        "signature": "WindowGrid.logger",
        "stripped_doc": "",
        "type": "Variable"
      }
    ],
    "desc": "Configure and assign hotkey for `hs.grid`",
    "doc": "Configure and assign hotkey for `hs.grid`\n\nDownload: [https://github.com/Hammerspoon/Spoons/raw/master/Spoons/WindowGrid.spoon.zip](https://github.com/Hammerspoon/Spoons/raw/master/Spoons/WindowGrid.spoon.zip)",
    "items": [
      {
        "def": "WindowGrid:bindHotkeys(mapping)",
        "desc": "Binds hotkeys for WindowGrid",
        "doc": "Binds hotkeys for WindowGrid\n\nParameters:\n * mapping - A table containing hotkey objifier/key details for the following items:\n  * show_grid - show the grid overlay",
        "name": "bindHotkeys",
        "parameters": [
          " * mapping - A table containing hotkey objifier/key details for the following items:",
          "  * show_grid - show the grid overlay"
        ],
        "signature": "WindowGrid:bindHotkeys(mapping)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "WindowGrid.gridGeometries",
        "desc": "Table containing a list of arguments to be passed to grid.setGrid(). Each element in the table is itself a table with 1-3 arguments as defined for [hs.grid.setGrid()](http://www.hammerspoon.org/docs/hs.grid.html#setGrid). Defaults to an empty list, which results in the default 3x3 grid for all screen from `hs.grid`.",
        "doc": "Table containing a list of arguments to be passed to grid.setGrid(). Each element in the table is itself a table with 1-3 arguments as defined for [hs.grid.setGrid()](http://www.hammerspoon.org/docs/hs.grid.html#setGrid). Defaults to an empty list, which results in the default 3x3 grid for all screen from `hs.grid`.",
        "name": "gridGeometries",
        "signature": "WindowGrid.gridGeometries",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "WindowGrid.logger",
        "desc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "doc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "name": "logger",
        "signature": "WindowGrid.logger",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "WindowGrid:start()",
        "desc": "Sets the grid configuration according to `WindowGrid.gridGeometries`.",
        "doc": "Sets the grid configuration according to `WindowGrid.gridGeometries`.",
        "name": "start",
        "signature": "WindowGrid:start()",
        "stripped_doc": "",
        "type": "Method"
      }
    ],
    "name": "WindowGrid",
    "stripped_doc": "\nDownload: [https://github.com/Hammerspoon/Spoons/raw/master/Spoons/WindowGrid.spoon.zip](https://github.com/Hammerspoon/Spoons/raw/master/Spoons/WindowGrid.spoon.zip)",
    "submodules": [],
    "type": "Module"
  },
  {
    "Command": [],
    "Constant": [],
    "Constructor": [],
    "Deprecated": [],
    "Field": [],
    "Function": [],
    "Method": [
      {
        "def": "WindowHalfsAndThirds:bindHotkeys(mapping)",
        "desc": "Binds hotkeys for WindowHalfsAndThirds",
        "doc": "Binds hotkeys for WindowHalfsAndThirds\n\nParameters:\n * mapping - A table containing hotkey objifier/key details for the following items:\n  * left_half, right_half, top_half, bottom_half - resize to the corresponding half of the screen\n  * third_left, third_right - resize to one horizontal-third of the screen and move left/right\n  * third_up, third_down - resize to one vertical-third of the screen and move up/down\n  * max - maximize the window\n  * max_toggle - toggle maximization\n  * screen_left, screen_right - move the window to the left/right screen (if you have more than one monitor connected, does nothing otherwise)\n  * top_third, middle_third_v, bottom_third - resize and move the window to the corresponding vertical third of the screen\n  * left_third, middle_third_h, right_third - resize and move the window to the corresponding horizontal third of the screen\n  * top_left, top_right, bottom_left, bottom_right - resize and move the window to the corresponding quarter of the screen",
        "name": "bindHotkeys",
        "parameters": [
          " * mapping - A table containing hotkey objifier/key details for the following items:",
          "  * left_half, right_half, top_half, bottom_half - resize to the corresponding half of the screen",
          "  * third_left, third_right - resize to one horizontal-third of the screen and move left/right",
          "  * third_up, third_down - resize to one vertical-third of the screen and move up/down",
          "  * max - maximize the window",
          "  * max_toggle - toggle maximization",
          "  * screen_left, screen_right - move the window to the left/right screen (if you have more than one monitor connected, does nothing otherwise)",
          "  * top_third, middle_third_v, bottom_third - resize and move the window to the corresponding vertical third of the screen",
          "  * left_third, middle_third_h, right_third - resize and move the window to the corresponding horizontal third of the screen",
          "  * top_left, top_right, bottom_left, bottom_right - resize and move the window to the corresponding quarter of the screen"
        ],
        "signature": "WindowHalfsAndThirds:bindHotkeys(mapping)",
        "stripped_doc": "",
        "type": "Method"
      }
    ],
    "Variable": [
      {
        "def": "WindowHalfsAndThirds.defaultHotkeys",
        "desc": "Table containing a sample set of hotkeys that can be",
        "doc": "Table containing a sample set of hotkeys that can be\nassigned to the different operations. These are not bound\nby default - if you want to use them you have to call:\n`spoon.WindowHalfsAndThirds:bindHotkeys(spoon.WindowHalfsAndThirds.defaultHotkeys)`\nafter loading the spoon. Value:\n```\n {\n    left_half   = { {\"ctrl\",        \"cmd\"}, \"Left\" },\n    right_half  = { {\"ctrl\",        \"cmd\"}, \"Right\" },\n    top_half    = { {\"ctrl\",        \"cmd\"}, \"Up\" },\n    bottom_half = { {\"ctrl\",        \"cmd\"}, \"Down\" },\n    third_left  = { {\"ctrl\", \"alt\"       }, \"Left\" },\n    third_right = { {\"ctrl\", \"alt\"       }, \"Right\" },\n    third_up    = { {\"ctrl\", \"alt\"       }, \"Up\" },\n    third_down  = { {\"ctrl\", \"alt\"       }, \"Down\" },\n    top_left    = { {\"ctrl\",        \"cmd\"}, \"1\" },\n    top_right   = { {\"ctrl\",        \"cmd\"}, \"2\" },\n    bottom_left = { {\"ctrl\",        \"cmd\"}, \"3\" },\n    bottom_right= { {\"ctrl\",        \"cmd\"}, \"4\" },\n    max_toggle  = { {\"ctrl\", \"alt\", \"cmd\"}, \"f\" },\n    max         = { {\"ctrl\", \"alt\", \"cmd\"}, \"Up\" },\n }\n```",
        "name": "defaultHotkeys",
        "signature": "WindowHalfsAndThirds.defaultHotkeys",
        "stripped_doc": "assigned to the different operations. These are not bound\nby default - if you want to use them you have to call:\n`spoon.WindowHalfsAndThirds:bindHotkeys(spoon.WindowHalfsAndThirds.defaultHotkeys)`\nafter loading the spoon. Value:\n```\n {\n    left_half   = { {\"ctrl\",        \"cmd\"}, \"Left\" },\n    right_half  = { {\"ctrl\",        \"cmd\"}, \"Right\" },\n    top_half    = { {\"ctrl\",        \"cmd\"}, \"Up\" },\n    bottom_half = { {\"ctrl\",        \"cmd\"}, \"Down\" },\n    third_left  = { {\"ctrl\", \"alt\"       }, \"Left\" },\n    third_right = { {\"ctrl\", \"alt\"       }, \"Right\" },\n    third_up    = { {\"ctrl\", \"alt\"       }, \"Up\" },\n    third_down  = { {\"ctrl\", \"alt\"       }, \"Down\" },\n    top_left    = { {\"ctrl\",        \"cmd\"}, \"1\" },\n    top_right   = { {\"ctrl\",        \"cmd\"}, \"2\" },\n    bottom_left = { {\"ctrl\",        \"cmd\"}, \"3\" },\n    bottom_right= { {\"ctrl\",        \"cmd\"}, \"4\" },\n    max_toggle  = { {\"ctrl\", \"alt\", \"cmd\"}, \"f\" },\n    max         = { {\"ctrl\", \"alt\", \"cmd\"}, \"Up\" },\n }\n```",
        "type": "Variable"
      },
      {
        "def": "WindowHalfsAndThirds.logger",
        "desc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "doc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "name": "logger",
        "signature": "WindowHalfsAndThirds.logger",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "WindowHalfsAndThirds.use_frame_correctness",
        "desc": "If `true`, set [setFrameCorrectness](http://www.hammerspoon.org/docs/hs.window.html#setFrameCorrectness) for some resizing operations which fail when the window extends beyonds screen boundaries. This may cause some jerkiness in the resizing, so experiment and determine if you need it. Defaults to `false`",
        "doc": "If `true`, set [setFrameCorrectness](http://www.hammerspoon.org/docs/hs.window.html#setFrameCorrectness) for some resizing operations which fail when the window extends beyonds screen boundaries. This may cause some jerkiness in the resizing, so experiment and determine if you need it. Defaults to `false`",
        "name": "use_frame_correctness",
        "signature": "WindowHalfsAndThirds.use_frame_correctness",
        "stripped_doc": "",
        "type": "Variable"
      }
    ],
    "desc": "Simple window movement and resizing, focusing on half- and third-of-screen sizes",
    "doc": "Simple window movement and resizing, focusing on half- and third-of-screen sizes\n\nDownload: [https://github.com/Hammerspoon/Spoons/raw/master/Spoons/WindowHalfsAndThirds.spoon.zip](https://github.com/Hammerspoon/Spoons/raw/master/Spoons/WindowHalfsAndThirds.spoon.zip)",
    "items": [
      {
        "def": "WindowHalfsAndThirds:bindHotkeys(mapping)",
        "desc": "Binds hotkeys for WindowHalfsAndThirds",
        "doc": "Binds hotkeys for WindowHalfsAndThirds\n\nParameters:\n * mapping - A table containing hotkey objifier/key details for the following items:\n  * left_half, right_half, top_half, bottom_half - resize to the corresponding half of the screen\n  * third_left, third_right - resize to one horizontal-third of the screen and move left/right\n  * third_up, third_down - resize to one vertical-third of the screen and move up/down\n  * max - maximize the window\n  * max_toggle - toggle maximization\n  * screen_left, screen_right - move the window to the left/right screen (if you have more than one monitor connected, does nothing otherwise)\n  * top_third, middle_third_v, bottom_third - resize and move the window to the corresponding vertical third of the screen\n  * left_third, middle_third_h, right_third - resize and move the window to the corresponding horizontal third of the screen\n  * top_left, top_right, bottom_left, bottom_right - resize and move the window to the corresponding quarter of the screen",
        "name": "bindHotkeys",
        "parameters": [
          " * mapping - A table containing hotkey objifier/key details for the following items:",
          "  * left_half, right_half, top_half, bottom_half - resize to the corresponding half of the screen",
          "  * third_left, third_right - resize to one horizontal-third of the screen and move left/right",
          "  * third_up, third_down - resize to one vertical-third of the screen and move up/down",
          "  * max - maximize the window",
          "  * max_toggle - toggle maximization",
          "  * screen_left, screen_right - move the window to the left/right screen (if you have more than one monitor connected, does nothing otherwise)",
          "  * top_third, middle_third_v, bottom_third - resize and move the window to the corresponding vertical third of the screen",
          "  * left_third, middle_third_h, right_third - resize and move the window to the corresponding horizontal third of the screen",
          "  * top_left, top_right, bottom_left, bottom_right - resize and move the window to the corresponding quarter of the screen"
        ],
        "signature": "WindowHalfsAndThirds:bindHotkeys(mapping)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "WindowHalfsAndThirds.defaultHotkeys",
        "desc": "Table containing a sample set of hotkeys that can be",
        "doc": "Table containing a sample set of hotkeys that can be\nassigned to the different operations. These are not bound\nby default - if you want to use them you have to call:\n`spoon.WindowHalfsAndThirds:bindHotkeys(spoon.WindowHalfsAndThirds.defaultHotkeys)`\nafter loading the spoon. Value:\n```\n {\n    left_half   = { {\"ctrl\",        \"cmd\"}, \"Left\" },\n    right_half  = { {\"ctrl\",        \"cmd\"}, \"Right\" },\n    top_half    = { {\"ctrl\",        \"cmd\"}, \"Up\" },\n    bottom_half = { {\"ctrl\",        \"cmd\"}, \"Down\" },\n    third_left  = { {\"ctrl\", \"alt\"       }, \"Left\" },\n    third_right = { {\"ctrl\", \"alt\"       }, \"Right\" },\n    third_up    = { {\"ctrl\", \"alt\"       }, \"Up\" },\n    third_down  = { {\"ctrl\", \"alt\"       }, \"Down\" },\n    top_left    = { {\"ctrl\",        \"cmd\"}, \"1\" },\n    top_right   = { {\"ctrl\",        \"cmd\"}, \"2\" },\n    bottom_left = { {\"ctrl\",        \"cmd\"}, \"3\" },\n    bottom_right= { {\"ctrl\",        \"cmd\"}, \"4\" },\n    max_toggle  = { {\"ctrl\", \"alt\", \"cmd\"}, \"f\" },\n    max         = { {\"ctrl\", \"alt\", \"cmd\"}, \"Up\" },\n }\n```",
        "name": "defaultHotkeys",
        "signature": "WindowHalfsAndThirds.defaultHotkeys",
        "stripped_doc": "assigned to the different operations. These are not bound\nby default - if you want to use them you have to call:\n`spoon.WindowHalfsAndThirds:bindHotkeys(spoon.WindowHalfsAndThirds.defaultHotkeys)`\nafter loading the spoon. Value:\n```\n {\n    left_half   = { {\"ctrl\",        \"cmd\"}, \"Left\" },\n    right_half  = { {\"ctrl\",        \"cmd\"}, \"Right\" },\n    top_half    = { {\"ctrl\",        \"cmd\"}, \"Up\" },\n    bottom_half = { {\"ctrl\",        \"cmd\"}, \"Down\" },\n    third_left  = { {\"ctrl\", \"alt\"       }, \"Left\" },\n    third_right = { {\"ctrl\", \"alt\"       }, \"Right\" },\n    third_up    = { {\"ctrl\", \"alt\"       }, \"Up\" },\n    third_down  = { {\"ctrl\", \"alt\"       }, \"Down\" },\n    top_left    = { {\"ctrl\",        \"cmd\"}, \"1\" },\n    top_right   = { {\"ctrl\",        \"cmd\"}, \"2\" },\n    bottom_left = { {\"ctrl\",        \"cmd\"}, \"3\" },\n    bottom_right= { {\"ctrl\",        \"cmd\"}, \"4\" },\n    max_toggle  = { {\"ctrl\", \"alt\", \"cmd\"}, \"f\" },\n    max         = { {\"ctrl\", \"alt\", \"cmd\"}, \"Up\" },\n }\n```",
        "type": "Variable"
      },
      {
        "def": "WindowHalfsAndThirds.logger",
        "desc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "doc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "name": "logger",
        "signature": "WindowHalfsAndThirds.logger",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "WindowHalfsAndThirds.use_frame_correctness",
        "desc": "If `true`, set [setFrameCorrectness](http://www.hammerspoon.org/docs/hs.window.html#setFrameCorrectness) for some resizing operations which fail when the window extends beyonds screen boundaries. This may cause some jerkiness in the resizing, so experiment and determine if you need it. Defaults to `false`",
        "doc": "If `true`, set [setFrameCorrectness](http://www.hammerspoon.org/docs/hs.window.html#setFrameCorrectness) for some resizing operations which fail when the window extends beyonds screen boundaries. This may cause some jerkiness in the resizing, so experiment and determine if you need it. Defaults to `false`",
        "name": "use_frame_correctness",
        "signature": "WindowHalfsAndThirds.use_frame_correctness",
        "stripped_doc": "",
        "type": "Variable"
      }
    ],
    "name": "WindowHalfsAndThirds",
    "stripped_doc": "\nDownload: [https://github.com/Hammerspoon/Spoons/raw/master/Spoons/WindowHalfsAndThirds.spoon.zip](https://github.com/Hammerspoon/Spoons/raw/master/Spoons/WindowHalfsAndThirds.spoon.zip)",
    "submodules": [],
    "type": "Module"
  },
  {
    "Command": [],
    "Constant": [],
    "Constructor": [],
    "Deprecated": [],
    "Field": [],
    "Function": [],
    "Method": [
      {
        "def": "WindowScreenLeftAndRight:bindHotkeys(mapping)",
        "desc": "Binds hotkeys for WindowScreenLeftAndRight",
        "doc": "Binds hotkeys for WindowScreenLeftAndRight\n\nParameters:\n * mapping - A table containing hotkey objifier/key details for the following items:\n  * screen_left, screen_right - move the window to the left/right screen (if you have more than one monitor connected, does nothing otherwise)",
        "name": "bindHotkeys",
        "parameters": [
          " * mapping - A table containing hotkey objifier/key details for the following items:",
          "  * screen_left, screen_right - move the window to the left/right screen (if you have more than one monitor connected, does nothing otherwise)"
        ],
        "signature": "WindowScreenLeftAndRight:bindHotkeys(mapping)",
        "stripped_doc": "",
        "type": "Method"
      }
    ],
    "Variable": [
      {
        "def": "WindowScreenLeftAndRight.defaultHotkeys",
        "desc": "Table containing a sample set of hotkeys that can be",
        "doc": "Table containing a sample set of hotkeys that can be\nassigned to the different operations. These are not bound\nby default - if you want to use them you have to call:\n`spoon.WindowScreenLeftAndRight:bindHotkeys(spoon.WindowScreenLeftAndRight.defaultHotkeys)`\nafter loading the spoon. Value:\n```\n {\n    screen_left = { {\"ctrl\", \"alt\", \"cmd\"}, \"Left\" },\n    screen_right= { {\"ctrl\", \"alt\", \"cmd\"}, \"Right\" },\n }\n```",
        "name": "defaultHotkeys",
        "signature": "WindowScreenLeftAndRight.defaultHotkeys",
        "stripped_doc": "assigned to the different operations. These are not bound\nby default - if you want to use them you have to call:\n`spoon.WindowScreenLeftAndRight:bindHotkeys(spoon.WindowScreenLeftAndRight.defaultHotkeys)`\nafter loading the spoon. Value:\n```\n {\n    screen_left = { {\"ctrl\", \"alt\", \"cmd\"}, \"Left\" },\n    screen_right= { {\"ctrl\", \"alt\", \"cmd\"}, \"Right\" },\n }\n```",
        "type": "Variable"
      },
      {
        "def": "WindowScreenLeftAndRight.logger",
        "desc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "doc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "name": "logger",
        "signature": "WindowScreenLeftAndRight.logger",
        "stripped_doc": "",
        "type": "Variable"
      }
    ],
    "desc": "Move windows to other screens",
    "doc": "Move windows to other screens\n\nDownload: [https://github.com/Hammerspoon/Spoons/raw/master/Spoons/WindowScreenLeftAndRight.spoon.zip](https://github.com/Hammerspoon/Spoons/raw/master/Spoons/WindowScreenLeftAndRight.spoon.zip)",
    "items": [
      {
        "def": "WindowScreenLeftAndRight:bindHotkeys(mapping)",
        "desc": "Binds hotkeys for WindowScreenLeftAndRight",
        "doc": "Binds hotkeys for WindowScreenLeftAndRight\n\nParameters:\n * mapping - A table containing hotkey objifier/key details for the following items:\n  * screen_left, screen_right - move the window to the left/right screen (if you have more than one monitor connected, does nothing otherwise)",
        "name": "bindHotkeys",
        "parameters": [
          " * mapping - A table containing hotkey objifier/key details for the following items:",
          "  * screen_left, screen_right - move the window to the left/right screen (if you have more than one monitor connected, does nothing otherwise)"
        ],
        "signature": "WindowScreenLeftAndRight:bindHotkeys(mapping)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "WindowScreenLeftAndRight.defaultHotkeys",
        "desc": "Table containing a sample set of hotkeys that can be",
        "doc": "Table containing a sample set of hotkeys that can be\nassigned to the different operations. These are not bound\nby default - if you want to use them you have to call:\n`spoon.WindowScreenLeftAndRight:bindHotkeys(spoon.WindowScreenLeftAndRight.defaultHotkeys)`\nafter loading the spoon. Value:\n```\n {\n    screen_left = { {\"ctrl\", \"alt\", \"cmd\"}, \"Left\" },\n    screen_right= { {\"ctrl\", \"alt\", \"cmd\"}, \"Right\" },\n }\n```",
        "name": "defaultHotkeys",
        "signature": "WindowScreenLeftAndRight.defaultHotkeys",
        "stripped_doc": "assigned to the different operations. These are not bound\nby default - if you want to use them you have to call:\n`spoon.WindowScreenLeftAndRight:bindHotkeys(spoon.WindowScreenLeftAndRight.defaultHotkeys)`\nafter loading the spoon. Value:\n```\n {\n    screen_left = { {\"ctrl\", \"alt\", \"cmd\"}, \"Left\" },\n    screen_right= { {\"ctrl\", \"alt\", \"cmd\"}, \"Right\" },\n }\n```",
        "type": "Variable"
      },
      {
        "def": "WindowScreenLeftAndRight.logger",
        "desc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "doc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "name": "logger",
        "signature": "WindowScreenLeftAndRight.logger",
        "stripped_doc": "",
        "type": "Variable"
      }
    ],
    "name": "WindowScreenLeftAndRight",
    "stripped_doc": "\nDownload: [https://github.com/Hammerspoon/Spoons/raw/master/Spoons/WindowScreenLeftAndRight.spoon.zip](https://github.com/Hammerspoon/Spoons/raw/master/Spoons/WindowScreenLeftAndRight.spoon.zip)",
    "submodules": [],
    "type": "Module"
  }
]