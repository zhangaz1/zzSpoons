[
  {
    "Command": [],
    "Constant": [],
    "Constructor": [],
    "Deprecated": [],
    "Field": [],
    "Function": [],
    "Method": [
      {
        "def": "EvernoteOpenAndTag:bindHotkeys(mapping)",
        "desc": "Binds hotkeys for EvernoteOpenAndTag",
        "doc": "Binds hotkeys for EvernoteOpenAndTag\n\nParameters:\n * mapping - A table containing hotkey objifier/key details for the following items:\n  * `open_note` - open the current note in a new window\n  * `open_and_tag-<tag1>,<tag2>...` - open the current note and apply all the comma-separated tags given. The tags must already exist in Evernote for the tagging to succeed.\n  * `tag-<tag1>,<tag2>...` - open the current note and apply all the comma-separated tags given. The tags must already exist in Evernote for the tagging to succeed.",
        "name": "bindHotkeys",
        "parameters": [
          " * mapping - A table containing hotkey objifier/key details for the following items:",
          "  * `open_note` - open the current note in a new window",
          "  * `open_and_tag-<tag1>,<tag2>...` - open the current note and apply all the comma-separated tags given. The tags must already exist in Evernote for the tagging to succeed.",
          "  * `tag-<tag1>,<tag2>...` - open the current note and apply all the comma-separated tags given. The tags must already exist in Evernote for the tagging to succeed."
        ],
        "signature": "EvernoteOpenAndTag:bindHotkeys(mapping)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "EvernoteOpenAndTag:evernoteIsFrontmost()",
        "desc": "Returns `true` if Evernote is the frontmost application",
        "doc": "Returns `true` if Evernote is the frontmost application\n\nParameters:\n * None\n\nReturns:\n * `true` if Evernote is the frontmost application, `false` otherwise",
        "name": "evernoteIsFrontmost",
        "parameters": [
          " * None"
        ],
        "returns": [
          " * `true` if Evernote is the frontmost application, `false` otherwise"
        ],
        "signature": "EvernoteOpenAndTag:evernoteIsFrontmost()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "EvernoteOpenAndTag:inlineTagCurrentNote(tags)",
        "desc": "Apply the given tags to the selected Evernote notes",
        "doc": "Apply the given tags to the selected Evernote notes\n\nParameters:\n * tags - a table containing a list of tags to apply. The tags must already exist in Evernote.\n\nReturns:\n * None\n\nNotes:\n * If multiple notes are selected, the tags are applied to all of them",
        "name": "inlineTagCurrentNote",
        "notes": [
          " * If multiple notes are selected, the tags are applied to all of them"
        ],
        "parameters": [
          " * tags - a table containing a list of tags to apply. The tags must already exist in Evernote."
        ],
        "returns": [
          " * None"
        ],
        "signature": "EvernoteOpenAndTag:inlineTagCurrentNote(tags)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "EvernoteOpenAndTag:openAndTagCurrentNote(tags)",
        "desc": "Open the current Evernote note in a new window and apply the given tags to it",
        "doc": "Open the current Evernote note in a new window and apply the given tags to it\n\nParameters:\n * tags - a table containing a list of tags to apply. The tags must already exist in Evernote.\n\nReturns:\n * None\n\nNotes:\n * Even if multiple notes are selected, only the first one is tagged, as it will become the \"current one\" after it's opened in a new window",
        "name": "openAndTagCurrentNote",
        "notes": [
          " * Even if multiple notes are selected, only the first one is tagged, as it will become the \"current one\" after it's opened in a new window"
        ],
        "parameters": [
          " * tags - a table containing a list of tags to apply. The tags must already exist in Evernote."
        ],
        "returns": [
          " * None"
        ],
        "signature": "EvernoteOpenAndTag:openAndTagCurrentNote(tags)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "EvernoteOpenAndTag:openCurrentNoteInWindow()",
        "desc": "Open the currently-selected Evernote notes in new windows.",
        "doc": "Open the currently-selected Evernote notes in new windows.\nUses Applescript from https://discussion.evernote.com/topic/85685-feature-request-open-note-in-separate-window-keyboard-shortcut/#comment-366797\n\nParameters:\n * None\n\nReturns:\n * None",
        "name": "openCurrentNoteInWindow",
        "parameters": [
          " * None"
        ],
        "returns": [
          " * None"
        ],
        "signature": "EvernoteOpenAndTag:openCurrentNoteInWindow()",
        "stripped_doc": "Uses Applescript from https://discussion.evernote.com/topic/85685-feature-request-open-note-in-separate-window-keyboard-shortcut/#comment-366797",
        "type": "Method"
      },
      {
        "def": "EvernoteOpenAndTag:tagCurrentNote(tags)",
        "desc": "Assigns tags to the currently-selected Evernote notes",
        "doc": "Assigns tags to the currently-selected Evernote notes\n\nParameters:\n * tags - a table containing a list of tags to apply. The tags must already exist in Evernote.\n\nReturns:\n * None",
        "name": "tagCurrentNote",
        "parameters": [
          " * tags - a table containing a list of tags to apply. The tags must already exist in Evernote."
        ],
        "returns": [
          " * None"
        ],
        "signature": "EvernoteOpenAndTag:tagCurrentNote(tags)",
        "stripped_doc": "",
        "type": "Method"
      }
    ],
    "Variable": [
      {
        "def": "EvernoteOpenAndTag.logger",
        "desc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "doc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "name": "logger",
        "signature": "EvernoteOpenAndTag.logger",
        "stripped_doc": "",
        "type": "Variable"
      }
    ],
    "desc": "Add some missing hotkeys for opening a note in Evernote, and for common tag sets",
    "doc": "Add some missing hotkeys for opening a note in Evernote, and for common tag sets\n\nDownload: [https://github.com/Hammerspoon/Spoons/raw/master/Spoons/EvernoteOpenAndTag.spoon.zip](https://github.com/Hammerspoon/Spoons/raw/master/Spoons/EvernoteOpenAndTag.spoon.zip)",
    "items": [
      {
        "def": "EvernoteOpenAndTag:bindHotkeys(mapping)",
        "desc": "Binds hotkeys for EvernoteOpenAndTag",
        "doc": "Binds hotkeys for EvernoteOpenAndTag\n\nParameters:\n * mapping - A table containing hotkey objifier/key details for the following items:\n  * `open_note` - open the current note in a new window\n  * `open_and_tag-<tag1>,<tag2>...` - open the current note and apply all the comma-separated tags given. The tags must already exist in Evernote for the tagging to succeed.\n  * `tag-<tag1>,<tag2>...` - open the current note and apply all the comma-separated tags given. The tags must already exist in Evernote for the tagging to succeed.",
        "name": "bindHotkeys",
        "parameters": [
          " * mapping - A table containing hotkey objifier/key details for the following items:",
          "  * `open_note` - open the current note in a new window",
          "  * `open_and_tag-<tag1>,<tag2>...` - open the current note and apply all the comma-separated tags given. The tags must already exist in Evernote for the tagging to succeed.",
          "  * `tag-<tag1>,<tag2>...` - open the current note and apply all the comma-separated tags given. The tags must already exist in Evernote for the tagging to succeed."
        ],
        "signature": "EvernoteOpenAndTag:bindHotkeys(mapping)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "EvernoteOpenAndTag:evernoteIsFrontmost()",
        "desc": "Returns `true` if Evernote is the frontmost application",
        "doc": "Returns `true` if Evernote is the frontmost application\n\nParameters:\n * None\n\nReturns:\n * `true` if Evernote is the frontmost application, `false` otherwise",
        "name": "evernoteIsFrontmost",
        "parameters": [
          " * None"
        ],
        "returns": [
          " * `true` if Evernote is the frontmost application, `false` otherwise"
        ],
        "signature": "EvernoteOpenAndTag:evernoteIsFrontmost()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "EvernoteOpenAndTag:inlineTagCurrentNote(tags)",
        "desc": "Apply the given tags to the selected Evernote notes",
        "doc": "Apply the given tags to the selected Evernote notes\n\nParameters:\n * tags - a table containing a list of tags to apply. The tags must already exist in Evernote.\n\nReturns:\n * None\n\nNotes:\n * If multiple notes are selected, the tags are applied to all of them",
        "name": "inlineTagCurrentNote",
        "notes": [
          " * If multiple notes are selected, the tags are applied to all of them"
        ],
        "parameters": [
          " * tags - a table containing a list of tags to apply. The tags must already exist in Evernote."
        ],
        "returns": [
          " * None"
        ],
        "signature": "EvernoteOpenAndTag:inlineTagCurrentNote(tags)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "EvernoteOpenAndTag.logger",
        "desc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "doc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "name": "logger",
        "signature": "EvernoteOpenAndTag.logger",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "EvernoteOpenAndTag:openAndTagCurrentNote(tags)",
        "desc": "Open the current Evernote note in a new window and apply the given tags to it",
        "doc": "Open the current Evernote note in a new window and apply the given tags to it\n\nParameters:\n * tags - a table containing a list of tags to apply. The tags must already exist in Evernote.\n\nReturns:\n * None\n\nNotes:\n * Even if multiple notes are selected, only the first one is tagged, as it will become the \"current one\" after it's opened in a new window",
        "name": "openAndTagCurrentNote",
        "notes": [
          " * Even if multiple notes are selected, only the first one is tagged, as it will become the \"current one\" after it's opened in a new window"
        ],
        "parameters": [
          " * tags - a table containing a list of tags to apply. The tags must already exist in Evernote."
        ],
        "returns": [
          " * None"
        ],
        "signature": "EvernoteOpenAndTag:openAndTagCurrentNote(tags)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "EvernoteOpenAndTag:openCurrentNoteInWindow()",
        "desc": "Open the currently-selected Evernote notes in new windows.",
        "doc": "Open the currently-selected Evernote notes in new windows.\nUses Applescript from https://discussion.evernote.com/topic/85685-feature-request-open-note-in-separate-window-keyboard-shortcut/#comment-366797\n\nParameters:\n * None\n\nReturns:\n * None",
        "name": "openCurrentNoteInWindow",
        "parameters": [
          " * None"
        ],
        "returns": [
          " * None"
        ],
        "signature": "EvernoteOpenAndTag:openCurrentNoteInWindow()",
        "stripped_doc": "Uses Applescript from https://discussion.evernote.com/topic/85685-feature-request-open-note-in-separate-window-keyboard-shortcut/#comment-366797",
        "type": "Method"
      },
      {
        "def": "EvernoteOpenAndTag:tagCurrentNote(tags)",
        "desc": "Assigns tags to the currently-selected Evernote notes",
        "doc": "Assigns tags to the currently-selected Evernote notes\n\nParameters:\n * tags - a table containing a list of tags to apply. The tags must already exist in Evernote.\n\nReturns:\n * None",
        "name": "tagCurrentNote",
        "parameters": [
          " * tags - a table containing a list of tags to apply. The tags must already exist in Evernote."
        ],
        "returns": [
          " * None"
        ],
        "signature": "EvernoteOpenAndTag:tagCurrentNote(tags)",
        "stripped_doc": "",
        "type": "Method"
      }
    ],
    "name": "EvernoteOpenAndTag",
    "stripped_doc": "\nDownload: [https://github.com/Hammerspoon/Spoons/raw/master/Spoons/EvernoteOpenAndTag.spoon.zip](https://github.com/Hammerspoon/Spoons/raw/master/Spoons/EvernoteOpenAndTag.spoon.zip)",
    "submodules": [],
    "type": "Module"
  },
  {
    "Command": [],
    "Constant": [],
    "Constructor": [],
    "Deprecated": [],
    "Field": [],
    "Function": [],
    "Method": [
      {
        "def": "Hammer:autoReloadConfig(files)",
        "desc": "Reload config only if any of the Lua files in `files` have changed",
        "doc": "Reload config only if any of the Lua files in `files` have changed",
        "name": "autoReloadConfig",
        "signature": "Hammer:autoReloadConfig(files)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "Hammer:bindHotkeys(mapping)",
        "desc": "Binds hotkeys for Hammer",
        "doc": "Binds hotkeys for Hammer\n\nParameters:\n * mapping - A table containing hotkey objifier/key details for the following items:\n  * config_reload - Manually trigger a config reload",
        "name": "bindHotkeys",
        "parameters": [
          " * mapping - A table containing hotkey objifier/key details for the following items:",
          "  * config_reload - Manually trigger a config reload"
        ],
        "signature": "Hammer:bindHotkeys(mapping)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "Hammer:reloadConfig()",
        "desc": "Manually reload configuration (wrapper around `hs.reload`)",
        "doc": "Manually reload configuration (wrapper around `hs.reload`)",
        "name": "reloadConfig",
        "signature": "Hammer:reloadConfig()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "Hammer:start()",
        "desc": "Start the Spoon. At the moment this includes:",
        "doc": "Start the Spoon. At the moment this includes:\n * Set up the file watcher for auto-config-reload",
        "name": "start",
        "signature": "Hammer:start()",
        "stripped_doc": " * Set up the file watcher for auto-config-reload",
        "type": "Method"
      }
    ],
    "Variable": [
      {
        "def": "Hammer.auto_reload_config",
        "desc": "If true, automatically reload Hammerspoon config when any `.lua` files inside `hs.configdir` changes",
        "doc": "If true, automatically reload Hammerspoon config when any `.lua` files inside `hs.configdir` changes",
        "name": "auto_reload_config",
        "signature": "Hammer.auto_reload_config",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "Hammer.install_cli",
        "desc": "If true, install the `hs` command line tool",
        "doc": "If true, install the `hs` command line tool",
        "name": "install_cli",
        "signature": "Hammer.install_cli",
        "stripped_doc": "",
        "type": "Variable"
      }
    ],
    "desc": "Automate some Hammerspoon configuration tasks",
    "doc": "Automate some Hammerspoon configuration tasks\n\nDownload: [https://github.com/Hammerspoon/Spoons/raw/master/Spoons/Hammer.spoon.zip](https://github.com/Hammerspoon/Spoons/raw/master/Spoons/Hammer.spoon.zip)",
    "items": [
      {
        "def": "Hammer.auto_reload_config",
        "desc": "If true, automatically reload Hammerspoon config when any `.lua` files inside `hs.configdir` changes",
        "doc": "If true, automatically reload Hammerspoon config when any `.lua` files inside `hs.configdir` changes",
        "name": "auto_reload_config",
        "signature": "Hammer.auto_reload_config",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "Hammer:autoReloadConfig(files)",
        "desc": "Reload config only if any of the Lua files in `files` have changed",
        "doc": "Reload config only if any of the Lua files in `files` have changed",
        "name": "autoReloadConfig",
        "signature": "Hammer:autoReloadConfig(files)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "Hammer:bindHotkeys(mapping)",
        "desc": "Binds hotkeys for Hammer",
        "doc": "Binds hotkeys for Hammer\n\nParameters:\n * mapping - A table containing hotkey objifier/key details for the following items:\n  * config_reload - Manually trigger a config reload",
        "name": "bindHotkeys",
        "parameters": [
          " * mapping - A table containing hotkey objifier/key details for the following items:",
          "  * config_reload - Manually trigger a config reload"
        ],
        "signature": "Hammer:bindHotkeys(mapping)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "Hammer.install_cli",
        "desc": "If true, install the `hs` command line tool",
        "doc": "If true, install the `hs` command line tool",
        "name": "install_cli",
        "signature": "Hammer.install_cli",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "Hammer:reloadConfig()",
        "desc": "Manually reload configuration (wrapper around `hs.reload`)",
        "doc": "Manually reload configuration (wrapper around `hs.reload`)",
        "name": "reloadConfig",
        "signature": "Hammer:reloadConfig()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "Hammer:start()",
        "desc": "Start the Spoon. At the moment this includes:",
        "doc": "Start the Spoon. At the moment this includes:\n * Set up the file watcher for auto-config-reload",
        "name": "start",
        "signature": "Hammer:start()",
        "stripped_doc": " * Set up the file watcher for auto-config-reload",
        "type": "Method"
      }
    ],
    "name": "Hammer",
    "stripped_doc": "\nDownload: [https://github.com/Hammerspoon/Spoons/raw/master/Spoons/Hammer.spoon.zip](https://github.com/Hammerspoon/Spoons/raw/master/Spoons/Hammer.spoon.zip)",
    "submodules": [],
    "type": "Module"
  },
  {
    "Command": [],
    "Constant": [],
    "Constructor": [],
    "Deprecated": [],
    "Field": [],
    "Function": [],
    "Method": [
      {
        "def": "HeadphoneAutoPause:audiodevwatch(dev_uid, event_name)",
        "desc": "Callback function to use as an audio device watcher, to pause/unpause the application on headphones plugged/unplugged",
        "doc": "Callback function to use as an audio device watcher, to pause/unpause the application on headphones plugged/unplugged",
        "name": "audiodevwatch",
        "signature": "HeadphoneAutoPause:audiodevwatch(dev_uid, event_name)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "HeadphoneAutoPause.defaultControlFns(app)",
        "desc": "Generate the most common set of application control definition.",
        "doc": "Generate the most common set of application control definition.\n\nParameters:\n * app - name of the application, with its correct letter casing (i.e. \"iTunes\"). The name as provided will be used to find the running application, and its lowercase version will be used to find the corresponding `hs.*` module.\n\nReturns:\n * A table in the correct format for `HeadphoneAutoPause.controlfns`, using the lower-case value of `app` as the module name (for example, if app = \"iTunes\", the module loaded will be `hs.itunes`, and assuming the functions `isPlaying()`, `play()` and `pause()` exist in that module.",
        "name": "defaultControlFns",
        "parameters": [
          " * app - name of the application, with its correct letter casing (i.e. \"iTunes\"). The name as provided will be used to find the running application, and its lowercase version will be used to find the corresponding `hs.*` module."
        ],
        "returns": [
          " * A table in the correct format for `HeadphoneAutoPause.controlfns`, using the lower-case value of `app` as the module name (for example, if app = \"iTunes\", the module loaded will be `hs.itunes`, and assuming the functions `isPlaying()`, `play()` and `pause()` exist in that module."
        ],
        "signature": "HeadphoneAutoPause.defaultControlFns(app)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "HeadphoneAutoPause:start()",
        "desc": "Start headphone detection on all audio devices that support it",
        "doc": "Start headphone detection on all audio devices that support it",
        "name": "start",
        "signature": "HeadphoneAutoPause:start()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "HeadphoneAutoPause:stop()",
        "desc": "Stop headphone detection",
        "doc": "Stop headphone detection",
        "name": "stop",
        "signature": "HeadphoneAutoPause:stop()",
        "stripped_doc": "",
        "type": "Method"
      }
    ],
    "Variable": [
      {
        "def": "HeadphoneAutoPause.control",
        "desc": "Table containing one key per application, with the value indicating whether HeadphoneAutoPause should try to pause/unpause that application in response to the headphone being plugged/unplugged. The key name must ideally correspond to the name of the corresponding `hs.*` module. Default value:",
        "doc": "Table containing one key per application, with the value indicating whether HeadphoneAutoPause should try to pause/unpause that application in response to the headphone being plugged/unplugged. The key name must ideally correspond to the name of the corresponding `hs.*` module. Default value:\n```\n{\n   itunes = true,\n   spotify = true,\n   deezer = true,\n   vox = false -- Vox has built-in headphone detection support\n}\n```",
        "name": "control",
        "signature": "HeadphoneAutoPause.control",
        "stripped_doc": "```\n{\n   itunes = true,\n   spotify = true,\n   deezer = true,\n   vox = false -- Vox has built-in headphone detection support\n}\n```",
        "type": "Variable"
      },
      {
        "def": "HeadphoneAutoPause.controlfns",
        "desc": "Table containing control functions for each application to control.",
        "doc": "Table containing control functions for each application to control.\nThe keys must correspond to the values in `HeadphoneAutoPause.control`, and the value is a table with the following elements:\n * `appname` - application name (case-sensitive, as the application appears to the system)\n * `isPlaying` - function that returns a true value if the application is playing\n * `play` - function that starts playback in the application\n * `pause` - function that pauses playback in the application\n\nThe default value includes definitions for iTunes, Spotify, Deezer and Vox, using the corresponding functions from `hs.itunes`, `hs.spotify`, `hs.deezer` and `hs.vox`, respectively.",
        "name": "controlfns",
        "signature": "HeadphoneAutoPause.controlfns",
        "stripped_doc": "The keys must correspond to the values in `HeadphoneAutoPause.control`, and the value is a table with the following elements:\n * `appname` - application name (case-sensitive, as the application appears to the system)\n * `isPlaying` - function that returns a true value if the application is playing\n * `play` - function that starts playback in the application\n * `pause` - function that pauses playback in the application\nThe default value includes definitions for iTunes, Spotify, Deezer and Vox, using the corresponding functions from `hs.itunes`, `hs.spotify`, `hs.deezer` and `hs.vox`, respectively.",
        "type": "Variable"
      },
      {
        "def": "HeadphoneAutoPause.logger",
        "desc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "doc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "name": "logger",
        "signature": "HeadphoneAutoPause.logger",
        "stripped_doc": "",
        "type": "Variable"
      }
    ],
    "desc": "Play/pause music players when headphones are connected/disconnected",
    "doc": "Play/pause music players when headphones are connected/disconnected\n\nDownload: [https://github.com/Hammerspoon/Spoons/raw/master/Spoons/HeadphoneAutoPause.spoon.zip](https://github.com/Hammerspoon/Spoons/raw/master/Spoons/HeadphoneAutoPause.spoon.zip)",
    "items": [
      {
        "def": "HeadphoneAutoPause:audiodevwatch(dev_uid, event_name)",
        "desc": "Callback function to use as an audio device watcher, to pause/unpause the application on headphones plugged/unplugged",
        "doc": "Callback function to use as an audio device watcher, to pause/unpause the application on headphones plugged/unplugged",
        "name": "audiodevwatch",
        "signature": "HeadphoneAutoPause:audiodevwatch(dev_uid, event_name)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "HeadphoneAutoPause.control",
        "desc": "Table containing one key per application, with the value indicating whether HeadphoneAutoPause should try to pause/unpause that application in response to the headphone being plugged/unplugged. The key name must ideally correspond to the name of the corresponding `hs.*` module. Default value:",
        "doc": "Table containing one key per application, with the value indicating whether HeadphoneAutoPause should try to pause/unpause that application in response to the headphone being plugged/unplugged. The key name must ideally correspond to the name of the corresponding `hs.*` module. Default value:\n```\n{\n   itunes = true,\n   spotify = true,\n   deezer = true,\n   vox = false -- Vox has built-in headphone detection support\n}\n```",
        "name": "control",
        "signature": "HeadphoneAutoPause.control",
        "stripped_doc": "```\n{\n   itunes = true,\n   spotify = true,\n   deezer = true,\n   vox = false -- Vox has built-in headphone detection support\n}\n```",
        "type": "Variable"
      },
      {
        "def": "HeadphoneAutoPause.controlfns",
        "desc": "Table containing control functions for each application to control.",
        "doc": "Table containing control functions for each application to control.\nThe keys must correspond to the values in `HeadphoneAutoPause.control`, and the value is a table with the following elements:\n * `appname` - application name (case-sensitive, as the application appears to the system)\n * `isPlaying` - function that returns a true value if the application is playing\n * `play` - function that starts playback in the application\n * `pause` - function that pauses playback in the application\n\nThe default value includes definitions for iTunes, Spotify, Deezer and Vox, using the corresponding functions from `hs.itunes`, `hs.spotify`, `hs.deezer` and `hs.vox`, respectively.",
        "name": "controlfns",
        "signature": "HeadphoneAutoPause.controlfns",
        "stripped_doc": "The keys must correspond to the values in `HeadphoneAutoPause.control`, and the value is a table with the following elements:\n * `appname` - application name (case-sensitive, as the application appears to the system)\n * `isPlaying` - function that returns a true value if the application is playing\n * `play` - function that starts playback in the application\n * `pause` - function that pauses playback in the application\nThe default value includes definitions for iTunes, Spotify, Deezer and Vox, using the corresponding functions from `hs.itunes`, `hs.spotify`, `hs.deezer` and `hs.vox`, respectively.",
        "type": "Variable"
      },
      {
        "def": "HeadphoneAutoPause.defaultControlFns(app)",
        "desc": "Generate the most common set of application control definition.",
        "doc": "Generate the most common set of application control definition.\n\nParameters:\n * app - name of the application, with its correct letter casing (i.e. \"iTunes\"). The name as provided will be used to find the running application, and its lowercase version will be used to find the corresponding `hs.*` module.\n\nReturns:\n * A table in the correct format for `HeadphoneAutoPause.controlfns`, using the lower-case value of `app` as the module name (for example, if app = \"iTunes\", the module loaded will be `hs.itunes`, and assuming the functions `isPlaying()`, `play()` and `pause()` exist in that module.",
        "name": "defaultControlFns",
        "parameters": [
          " * app - name of the application, with its correct letter casing (i.e. \"iTunes\"). The name as provided will be used to find the running application, and its lowercase version will be used to find the corresponding `hs.*` module."
        ],
        "returns": [
          " * A table in the correct format for `HeadphoneAutoPause.controlfns`, using the lower-case value of `app` as the module name (for example, if app = \"iTunes\", the module loaded will be `hs.itunes`, and assuming the functions `isPlaying()`, `play()` and `pause()` exist in that module."
        ],
        "signature": "HeadphoneAutoPause.defaultControlFns(app)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "HeadphoneAutoPause.logger",
        "desc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "doc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "name": "logger",
        "signature": "HeadphoneAutoPause.logger",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "HeadphoneAutoPause:start()",
        "desc": "Start headphone detection on all audio devices that support it",
        "doc": "Start headphone detection on all audio devices that support it",
        "name": "start",
        "signature": "HeadphoneAutoPause:start()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "HeadphoneAutoPause:stop()",
        "desc": "Stop headphone detection",
        "doc": "Stop headphone detection",
        "name": "stop",
        "signature": "HeadphoneAutoPause:stop()",
        "stripped_doc": "",
        "type": "Method"
      }
    ],
    "name": "HeadphoneAutoPause",
    "stripped_doc": "\nDownload: [https://github.com/Hammerspoon/Spoons/raw/master/Spoons/HeadphoneAutoPause.spoon.zip](https://github.com/Hammerspoon/Spoons/raw/master/Spoons/HeadphoneAutoPause.spoon.zip)",
    "submodules": [],
    "type": "Module"
  },
  {
    "Command": [],
    "Constant": [],
    "Constructor": [],
    "Deprecated": [],
    "Field": [],
    "Function": [],
    "Method": [
      {
        "def": "PopupTranslateSelection:bindHotkeys(mapping)",
        "desc": "Binds hotkeys for PopupTranslateSelection",
        "doc": "Binds hotkeys for PopupTranslateSelection\n\nParameters:\n * mapping - A table containing hotkey modifier/key details for the following items:\n  * translate - translate the selected text without specifying source/destination languages (source defaults to auto-detect, destination defaults to your last choice or to English)\n  * translate_to_<lang> - translate the selected text to the given destination language. Source language will be auto-detected.\n  * translate_from_<lang> - translate the selected text from the given destination language. Destination language will default to your last choice, or to English.\n  * translate_<from>_<to> - translate the selected text between the given languages.\n\nSample value for `mapping`:\n```\n {\n    translate_to_en = { hyper, \"e\" },\n    translate_to_de = { hyper, \"d\" },\n    translate_to_es = { hyper, \"s\" },\n    translate_de_en = { shift_hyper, \"e\" },\n    translate_en_de = { shift_hyper, \"d\" },\n }\n```",
        "name": "bindHotkeys",
        "parameters": [
          " * mapping - A table containing hotkey modifier/key details for the following items:",
          "  * translate - translate the selected text without specifying source/destination languages (source defaults to auto-detect, destination defaults to your last choice or to English)",
          "  * translate_to_<lang> - translate the selected text to the given destination language. Source language will be auto-detected.",
          "  * translate_from_<lang> - translate the selected text from the given destination language. Destination language will default to your last choice, or to English.",
          "  * translate_<from>_<to> - translate the selected text between the given languages."
        ],
        "signature": "PopupTranslateSelection:bindHotkeys(mapping)",
        "stripped_doc": "Sample value for `mapping`:\n```\n {\n    translate_to_en = { hyper, \"e\" },\n    translate_to_de = { hyper, \"d\" },\n    translate_to_es = { hyper, \"s\" },\n    translate_de_en = { shift_hyper, \"e\" },\n    translate_en_de = { shift_hyper, \"d\" },\n }\n```",
        "type": "Method"
      },
      {
        "def": "PopupTranslateSelection:translatePopup(text, to, from)",
        "desc": "Display a translation popup with the translation of the given text between the specified languages",
        "doc": "Display a translation popup with the translation of the given text between the specified languages\n\nParameters:\n * text - string containing the text to translate\n * to - two-letter code for destination language. If `nil`, Google Translate will use your most recent selection, or default to English\n * from - two-letter code for source language. If `nil`, Google Translate will try to auto-detect it\n\nReturns:\n * The PopupTranslateSelection object",
        "name": "translatePopup",
        "parameters": [
          " * text - string containing the text to translate",
          " * to - two-letter code for destination language. If `nil`, Google Translate will use your most recent selection, or default to English",
          " * from - two-letter code for source language. If `nil`, Google Translate will try to auto-detect it"
        ],
        "returns": [
          " * The PopupTranslateSelection object"
        ],
        "signature": "PopupTranslateSelection:translatePopup(text, to, from)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "PopupTranslateSelection:translateSelectionPopup(to, from)",
        "desc": "Get the current selected text in the frontmost window and display a translation popup with the translation between the specified languages",
        "doc": "Get the current selected text in the frontmost window and display a translation popup with the translation between the specified languages\n\nParameters:\n * to - two-letter code for destination language. If `nil`, Google Translate will use your most recent selection, or default to English\n * from - two-letter code for source language. If `nil`, Google Translate will try to auto-detect it\n\nReturns:\n * The PopupTranslateSelection object",
        "name": "translateSelectionPopup",
        "parameters": [
          " * to - two-letter code for destination language. If `nil`, Google Translate will use your most recent selection, or default to English",
          " * from - two-letter code for source language. If `nil`, Google Translate will try to auto-detect it"
        ],
        "returns": [
          " * The PopupTranslateSelection object"
        ],
        "signature": "PopupTranslateSelection:translateSelectionPopup(to, from)",
        "stripped_doc": "",
        "type": "Method"
      }
    ],
    "Variable": [
      {
        "def": "PopupTranslateSelection.logger",
        "desc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "doc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "name": "logger",
        "signature": "PopupTranslateSelection.logger",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "PopupTranslateSelection.popup_close_on_escape",
        "desc": "If true, pressing ESC on the popup window will close it. Defaults to `true`",
        "doc": "If true, pressing ESC on the popup window will close it. Defaults to `true`",
        "name": "popup_close_on_escape",
        "signature": "PopupTranslateSelection.popup_close_on_escape",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "PopupTranslateSelection.popup_size",
        "desc": "`hs.geometry` object representing the size to use for the translation popup window. Defaults to `hs.geometry.size(770, 610)`.",
        "doc": "`hs.geometry` object representing the size to use for the translation popup window. Defaults to `hs.geometry.size(770, 610)`.",
        "name": "popup_size",
        "signature": "PopupTranslateSelection.popup_size",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "PopupTranslateSelection.popup_style",
        "desc": "Value representing the window style to be used for the translation popup window. This value needs to be a valid argument to [`hs.webview.setStyle()`](http://www.hammerspoon.org/docs/hs.webview.html#windowStyle) (i.e. a combination of values from [`hs.webview.windowMasks`](http://www.hammerspoon.org/docs/hs.webview.html#windowMasks[]). Default value: `hs.webview.windowMasks.utility|hs.webview.windowMasks.HUD|hs.webview.windowMasks.titled|hs.webview.windowMasks.closable`",
        "doc": "Value representing the window style to be used for the translation popup window. This value needs to be a valid argument to [`hs.webview.setStyle()`](http://www.hammerspoon.org/docs/hs.webview.html#windowStyle) (i.e. a combination of values from [`hs.webview.windowMasks`](http://www.hammerspoon.org/docs/hs.webview.html#windowMasks[]). Default value: `hs.webview.windowMasks.utility|hs.webview.windowMasks.HUD|hs.webview.windowMasks.titled|hs.webview.windowMasks.closable`",
        "name": "popup_style",
        "signature": "PopupTranslateSelection.popup_style",
        "stripped_doc": "",
        "type": "Variable"
      }
    ],
    "desc": "Show a popup window with the translation of the currently selected (or other) text",
    "doc": "Show a popup window with the translation of the currently selected (or other) text\n\nSupported language codes are listed at https://cloud.google.com/translate/docs/languages\n\nDownload: [https://github.com/Hammerspoon/Spoons/raw/master/Spoons/PopupTranslateSelection.spoon.zip](https://github.com/Hammerspoon/Spoons/raw/master/Spoons/PopupTranslateSelection.spoon.zip)",
    "items": [
      {
        "def": "PopupTranslateSelection:bindHotkeys(mapping)",
        "desc": "Binds hotkeys for PopupTranslateSelection",
        "doc": "Binds hotkeys for PopupTranslateSelection\n\nParameters:\n * mapping - A table containing hotkey modifier/key details for the following items:\n  * translate - translate the selected text without specifying source/destination languages (source defaults to auto-detect, destination defaults to your last choice or to English)\n  * translate_to_<lang> - translate the selected text to the given destination language. Source language will be auto-detected.\n  * translate_from_<lang> - translate the selected text from the given destination language. Destination language will default to your last choice, or to English.\n  * translate_<from>_<to> - translate the selected text between the given languages.\n\nSample value for `mapping`:\n```\n {\n    translate_to_en = { hyper, \"e\" },\n    translate_to_de = { hyper, \"d\" },\n    translate_to_es = { hyper, \"s\" },\n    translate_de_en = { shift_hyper, \"e\" },\n    translate_en_de = { shift_hyper, \"d\" },\n }\n```",
        "name": "bindHotkeys",
        "parameters": [
          " * mapping - A table containing hotkey modifier/key details for the following items:",
          "  * translate - translate the selected text without specifying source/destination languages (source defaults to auto-detect, destination defaults to your last choice or to English)",
          "  * translate_to_<lang> - translate the selected text to the given destination language. Source language will be auto-detected.",
          "  * translate_from_<lang> - translate the selected text from the given destination language. Destination language will default to your last choice, or to English.",
          "  * translate_<from>_<to> - translate the selected text between the given languages."
        ],
        "signature": "PopupTranslateSelection:bindHotkeys(mapping)",
        "stripped_doc": "Sample value for `mapping`:\n```\n {\n    translate_to_en = { hyper, \"e\" },\n    translate_to_de = { hyper, \"d\" },\n    translate_to_es = { hyper, \"s\" },\n    translate_de_en = { shift_hyper, \"e\" },\n    translate_en_de = { shift_hyper, \"d\" },\n }\n```",
        "type": "Method"
      },
      {
        "def": "PopupTranslateSelection.logger",
        "desc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "doc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "name": "logger",
        "signature": "PopupTranslateSelection.logger",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "PopupTranslateSelection.popup_close_on_escape",
        "desc": "If true, pressing ESC on the popup window will close it. Defaults to `true`",
        "doc": "If true, pressing ESC on the popup window will close it. Defaults to `true`",
        "name": "popup_close_on_escape",
        "signature": "PopupTranslateSelection.popup_close_on_escape",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "PopupTranslateSelection.popup_size",
        "desc": "`hs.geometry` object representing the size to use for the translation popup window. Defaults to `hs.geometry.size(770, 610)`.",
        "doc": "`hs.geometry` object representing the size to use for the translation popup window. Defaults to `hs.geometry.size(770, 610)`.",
        "name": "popup_size",
        "signature": "PopupTranslateSelection.popup_size",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "PopupTranslateSelection.popup_style",
        "desc": "Value representing the window style to be used for the translation popup window. This value needs to be a valid argument to [`hs.webview.setStyle()`](http://www.hammerspoon.org/docs/hs.webview.html#windowStyle) (i.e. a combination of values from [`hs.webview.windowMasks`](http://www.hammerspoon.org/docs/hs.webview.html#windowMasks[]). Default value: `hs.webview.windowMasks.utility|hs.webview.windowMasks.HUD|hs.webview.windowMasks.titled|hs.webview.windowMasks.closable`",
        "doc": "Value representing the window style to be used for the translation popup window. This value needs to be a valid argument to [`hs.webview.setStyle()`](http://www.hammerspoon.org/docs/hs.webview.html#windowStyle) (i.e. a combination of values from [`hs.webview.windowMasks`](http://www.hammerspoon.org/docs/hs.webview.html#windowMasks[]). Default value: `hs.webview.windowMasks.utility|hs.webview.windowMasks.HUD|hs.webview.windowMasks.titled|hs.webview.windowMasks.closable`",
        "name": "popup_style",
        "signature": "PopupTranslateSelection.popup_style",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "PopupTranslateSelection:translatePopup(text, to, from)",
        "desc": "Display a translation popup with the translation of the given text between the specified languages",
        "doc": "Display a translation popup with the translation of the given text between the specified languages\n\nParameters:\n * text - string containing the text to translate\n * to - two-letter code for destination language. If `nil`, Google Translate will use your most recent selection, or default to English\n * from - two-letter code for source language. If `nil`, Google Translate will try to auto-detect it\n\nReturns:\n * The PopupTranslateSelection object",
        "name": "translatePopup",
        "parameters": [
          " * text - string containing the text to translate",
          " * to - two-letter code for destination language. If `nil`, Google Translate will use your most recent selection, or default to English",
          " * from - two-letter code for source language. If `nil`, Google Translate will try to auto-detect it"
        ],
        "returns": [
          " * The PopupTranslateSelection object"
        ],
        "signature": "PopupTranslateSelection:translatePopup(text, to, from)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "PopupTranslateSelection:translateSelectionPopup(to, from)",
        "desc": "Get the current selected text in the frontmost window and display a translation popup with the translation between the specified languages",
        "doc": "Get the current selected text in the frontmost window and display a translation popup with the translation between the specified languages\n\nParameters:\n * to - two-letter code for destination language. If `nil`, Google Translate will use your most recent selection, or default to English\n * from - two-letter code for source language. If `nil`, Google Translate will try to auto-detect it\n\nReturns:\n * The PopupTranslateSelection object",
        "name": "translateSelectionPopup",
        "parameters": [
          " * to - two-letter code for destination language. If `nil`, Google Translate will use your most recent selection, or default to English",
          " * from - two-letter code for source language. If `nil`, Google Translate will try to auto-detect it"
        ],
        "returns": [
          " * The PopupTranslateSelection object"
        ],
        "signature": "PopupTranslateSelection:translateSelectionPopup(to, from)",
        "stripped_doc": "",
        "type": "Method"
      }
    ],
    "name": "PopupTranslateSelection",
    "stripped_doc": "\nSupported language codes are listed at https://cloud.google.com/translate/docs/languages\n\nDownload: [https://github.com/Hammerspoon/Spoons/raw/master/Spoons/PopupTranslateSelection.spoon.zip](https://github.com/Hammerspoon/Spoons/raw/master/Spoons/PopupTranslateSelection.spoon.zip)",
    "submodules": [],
    "type": "Module"
  },
  {
    "Command": [],
    "Constant": [],
    "Constructor": [],
    "Deprecated": [],
    "Field": [],
    "Function": [],
    "Method": [
      {
        "def": "SpoonInstall:andUse(name, arg)",
        "desc": "Declaratively install, load and configure a Spoon",
        "doc": "Declaratively install, load and configure a Spoon\n\nParameters:\n * name - the name of the Spoon to install (without the `.spoon` extension). If the Spoon is already installed, it will be loaded using `hs.loadSpoon()`. If it is not installed, it will be installed using `SpoonInstall:asyncInstallSpoonFromRepo()` and then loaded.\n * arg - if provided, can be used to specify the configuration of the Spoon. The following keys are recognized (all are optional):\n   * repo - repository from where the Spoon should be installed if not present in the system, as defined in `SpoonInstall.repos`. Defaults to `\"default\"`.\n   * config - a table containing variables to be stored in the Spoon object to configure it. For example, `config = { answer = 42 }` will result in `spoon.<LoadedSpoon>.answer` being set to 42.\n   * hotkeys - a table containing hotkey bindings. If provided, will be passed as-is to the Spoon's `bindHotkeys()` method. The special string `\"default\"` can be given to use the Spoons `defaultHotkeys` variable, if it exists.\n   * fn - a function which will be called with the freshly-loaded Spoon object as its first argument.\n   * loglevel - if the Spoon has a variable called `logger`, its `setLogLevel()` method will be called with this value.\n   * start - if `true`, call the Spoon's `start()` method after configuring everything else.\n   * disable - if `true`, do nothing. Easier than commenting it out when you want to temporarily disable a spoon.\n\nReturns:\n * None",
        "name": "andUse",
        "parameters": [
          " * name - the name of the Spoon to install (without the `.spoon` extension). If the Spoon is already installed, it will be loaded using `hs.loadSpoon()`. If it is not installed, it will be installed using `SpoonInstall:asyncInstallSpoonFromRepo()` and then loaded.",
          " * arg - if provided, can be used to specify the configuration of the Spoon. The following keys are recognized (all are optional):",
          "   * repo - repository from where the Spoon should be installed if not present in the system, as defined in `SpoonInstall.repos`. Defaults to `\"default\"`.",
          "   * config - a table containing variables to be stored in the Spoon object to configure it. For example, `config = { answer = 42 }` will result in `spoon.<LoadedSpoon>.answer` being set to 42.",
          "   * hotkeys - a table containing hotkey bindings. If provided, will be passed as-is to the Spoon's `bindHotkeys()` method. The special string `\"default\"` can be given to use the Spoons `defaultHotkeys` variable, if it exists.",
          "   * fn - a function which will be called with the freshly-loaded Spoon object as its first argument.",
          "   * loglevel - if the Spoon has a variable called `logger`, its `setLogLevel()` method will be called with this value.",
          "   * start - if `true`, call the Spoon's `start()` method after configuring everything else.",
          "   * disable - if `true`, do nothing. Easier than commenting it out when you want to temporarily disable a spoon."
        ],
        "returns": [
          " * None"
        ],
        "signature": "SpoonInstall:andUse(name, arg)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "SpoonInstall:asyncInstallSpoonFromRepo(name, repo, callback)",
        "desc": "Asynchronously install a Spoon from a registered repository",
        "doc": "Asynchronously install a Spoon from a registered repository\n\nParameters:\n * name - Name of the Spoon to install.\n * repo - Name of the repository to use. Defaults to `\"default\"`\n * callback - if given, a function to call after the installation finishes (also if it fails). The function receives the following arguments:\n   * urlparts - Result of calling `hs.http.urlParts` on the URL of the Spoon zip file\n   * success - boolean indicating whether the installation was successful\n\nReturns:\n * `true` if the installation was correctly initiated (i.e. the repo and spoon name were correct), `false` otherwise.",
        "name": "asyncInstallSpoonFromRepo",
        "parameters": [
          " * name - Name of the Spoon to install.",
          " * repo - Name of the repository to use. Defaults to `\"default\"`",
          " * callback - if given, a function to call after the installation finishes (also if it fails). The function receives the following arguments:",
          "   * urlparts - Result of calling `hs.http.urlParts` on the URL of the Spoon zip file",
          "   * success - boolean indicating whether the installation was successful"
        ],
        "returns": [
          " * `true` if the installation was correctly initiated (i.e. the repo and spoon name were correct), `false` otherwise."
        ],
        "signature": "SpoonInstall:asyncInstallSpoonFromRepo(name, repo, callback)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "SpoonInstall:asyncInstallSpoonFromZipURL(url, callback)",
        "desc": "Asynchronously download a Spoon zip file and install it.",
        "doc": "Asynchronously download a Spoon zip file and install it.\n\nParameters:\n * url - URL of the zip file to install.\n * callback - if given, a function to call after the installation finishes (also if it fails). The function receives the following arguments:\n   * urlparts - Result of calling `hs.http.urlParts` on the URL of the Spoon zip file\n   * success - boolean indicating whether the installation was successful\n\nReturns:\n * `true` if the installation was correctly initiated (i.e. the URL is valid), `false` otherwise",
        "name": "asyncInstallSpoonFromZipURL",
        "parameters": [
          " * url - URL of the zip file to install.",
          " * callback - if given, a function to call after the installation finishes (also if it fails). The function receives the following arguments:",
          "   * urlparts - Result of calling `hs.http.urlParts` on the URL of the Spoon zip file",
          "   * success - boolean indicating whether the installation was successful"
        ],
        "returns": [
          " * `true` if the installation was correctly initiated (i.e. the URL is valid), `false` otherwise"
        ],
        "signature": "SpoonInstall:asyncInstallSpoonFromZipURL(url, callback)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "SpoonInstall:asyncUpdateRepo(repo, callback)",
        "desc": "Asynchronously fetch the information about the contents of a Spoon repository",
        "doc": "Asynchronously fetch the information about the contents of a Spoon repository\n\nParameters:\n * repo - name of the repository to update. Defaults to `\"default\"`.\n * callback - if given, a function to be called after the update finishes (also if it fails). The function will receive the following arguments:\n   * repo - name of the repository\n   * success - boolean indicating whether the update succeeded\n\nReturns:\n * `true` if the update was correctly initiated (i.e. the repo name is valid), `nil` otherwise\n\nNotes:\n * For now, the repository data is not persisted, so you need to update it after every restart if you want to use any of the install functions.",
        "name": "asyncUpdateRepo",
        "notes": [
          " * For now, the repository data is not persisted, so you need to update it after every restart if you want to use any of the install functions."
        ],
        "parameters": [
          " * repo - name of the repository to update. Defaults to `\"default\"`.",
          " * callback - if given, a function to be called after the update finishes (also if it fails). The function will receive the following arguments:",
          "   * repo - name of the repository",
          "   * success - boolean indicating whether the update succeeded"
        ],
        "returns": [
          " * `true` if the update was correctly initiated (i.e. the repo name is valid), `nil` otherwise"
        ],
        "signature": "SpoonInstall:asyncUpdateRepo(repo, callback)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "SpoonInstall:installSpoonFromRepo(name, repo)",
        "desc": "Synchronously install a Spoon from a registered repository",
        "doc": "Synchronously install a Spoon from a registered repository\n\nParameters:\n * name = Name of the Spoon to install.\n * repo - Name of the repository to use. Defaults to `\"default\"`\n\nReturns:\n * `true` if the installation was successful, `nil` otherwise.",
        "name": "installSpoonFromRepo",
        "parameters": [
          " * name = Name of the Spoon to install.",
          " * repo - Name of the repository to use. Defaults to `\"default\"`"
        ],
        "returns": [
          " * `true` if the installation was successful, `nil` otherwise."
        ],
        "signature": "SpoonInstall:installSpoonFromRepo(name, repo)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "SpoonInstall:installSpoonFromZipURL(url)",
        "desc": "Synchronously download a Spoon zip file and install it.",
        "doc": "Synchronously download a Spoon zip file and install it.\n\nParameters:\n * url - URL of the zip file to install.\n\nReturns:\n * `true` if the installation was successful, `nil` otherwise",
        "name": "installSpoonFromZipURL",
        "parameters": [
          " * url - URL of the zip file to install."
        ],
        "returns": [
          " * `true` if the installation was successful, `nil` otherwise"
        ],
        "signature": "SpoonInstall:installSpoonFromZipURL(url)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "SpoonInstall:repolist()",
        "desc": "Return a sorted list of registered Spoon repositories",
        "doc": "Return a sorted list of registered Spoon repositories\n\nParameters:\n * None\n\nReturns:\n * Table containing a list of strings with the repository identifiers",
        "name": "repolist",
        "parameters": [
          " * None"
        ],
        "returns": [
          " * Table containing a list of strings with the repository identifiers"
        ],
        "signature": "SpoonInstall:repolist()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "SpoonInstall:search(pat)",
        "desc": "Search repositories for a pattern",
        "doc": "Search repositories for a pattern\n\nParameters:\n * pat - Lua pattern that will be matched against the name and description of each spoon in the registered repositories. All text is converted to lowercase before searching it, so you can use all-lowercase in your pattern.\n\nReturns:\n * Table containing a list of matching entries. Each entry is a table with the following keys:\n   * name - Spoon name\n   * desc - description of the spoon\n   * repo - identifier in the repository where the match was found",
        "name": "search",
        "parameters": [
          " * pat - Lua pattern that will be matched against the name and description of each spoon in the registered repositories. All text is converted to lowercase before searching it, so you can use all-lowercase in your pattern."
        ],
        "returns": [
          " * Table containing a list of matching entries. Each entry is a table with the following keys:",
          "   * name - Spoon name",
          "   * desc - description of the spoon",
          "   * repo - identifier in the repository where the match was found"
        ],
        "signature": "SpoonInstall:search(pat)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "SpoonInstall:updateAllRepos()",
        "desc": "Synchronously fetch the information about the contents of all Spoon repositories registered in `SpoonInstall.repos`",
        "doc": "Synchronously fetch the information about the contents of all Spoon repositories registered in `SpoonInstall.repos`\n\nParameters:\n * None\n\nReturns:\n * None\n\nNotes:\n * This is a synchronous call, which means Hammerspoon will be blocked until it finishes.\n * For now, the repository data is not persisted, so you need to update it after every restart if you want to use any of the install functions.",
        "name": "updateAllRepos",
        "notes": [
          " * This is a synchronous call, which means Hammerspoon will be blocked until it finishes.",
          " * For now, the repository data is not persisted, so you need to update it after every restart if you want to use any of the install functions."
        ],
        "parameters": [
          " * None"
        ],
        "returns": [
          " * None"
        ],
        "signature": "SpoonInstall:updateAllRepos()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "SpoonInstall:updateRepo(repo)",
        "desc": "Synchronously fetch the information about the contents of a Spoon repository",
        "doc": "Synchronously fetch the information about the contents of a Spoon repository\n\nParameters:\n * repo - name of the repository to update. Defaults to `\"default\"`.\n\nReturns:\n * `true` if the update was successful, `nil` otherwise\n\nNotes:\n * This is a synchronous call, which means Hammerspoon will be blocked until it finishes. For use in your configuration files, it's advisable to use `SpoonInstall.asyncUpdateRepo()` instead.\n * For now, the repository data is not persisted, so you need to update it after every restart if you want to use any of the install functions.",
        "name": "updateRepo",
        "notes": [
          " * This is a synchronous call, which means Hammerspoon will be blocked until it finishes. For use in your configuration files, it's advisable to use `SpoonInstall.asyncUpdateRepo()` instead.",
          " * For now, the repository data is not persisted, so you need to update it after every restart if you want to use any of the install functions."
        ],
        "parameters": [
          " * repo - name of the repository to update. Defaults to `\"default\"`."
        ],
        "returns": [
          " * `true` if the update was successful, `nil` otherwise"
        ],
        "signature": "SpoonInstall:updateRepo(repo)",
        "stripped_doc": "",
        "type": "Method"
      }
    ],
    "Variable": [
      {
        "def": "SpoonInstall.logger",
        "desc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "doc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "name": "logger",
        "signature": "SpoonInstall.logger",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "SpoonInstall.repos",
        "desc": "Table containing the list of available Spoon repositories. The key",
        "doc": "Table containing the list of available Spoon repositories. The key\nof each entry is an identifier for the repository, and its value\nis a table with the following entries:\n * desc - Human-readable description for the repository\n * url - Base URL for the repository. For now the repository is assumed to be hosted in GitHub, and the URL should be the main base URL of the repository. Repository metadata needs to be stored under `docs/docs.json`, and the Spoon zip files need to be stored under `Spoons/`.\n\nDefault value:\n```\n{\n   default = {\n      url = \"https://github.com/Hammerspoon/Spoons\",\n      desc = \"Main Hammerspoon Spoon repository\",\n   }\n}\n```",
        "name": "repos",
        "signature": "SpoonInstall.repos",
        "stripped_doc": "of each entry is an identifier for the repository, and its value\nis a table with the following entries:\n * desc - Human-readable description for the repository\n * url - Base URL for the repository. For now the repository is assumed to be hosted in GitHub, and the URL should be the main base URL of the repository. Repository metadata needs to be stored under `docs/docs.json`, and the Spoon zip files need to be stored under `Spoons/`.\nDefault value:\n```\n{\n   default = {\n      url = \"https://github.com/Hammerspoon/Spoons\",\n      desc = \"Main Hammerspoon Spoon repository\",\n   }\n}\n```",
        "type": "Variable"
      },
      {
        "def": "SpoonInstall.use_syncinstall",
        "desc": "If `true`, `andUse()` will update repos and install packages synchronously. Defaults to `false`.",
        "doc": "If `true`, `andUse()` will update repos and install packages synchronously. Defaults to `false`.\n\nKeep in mind that if you set this to `true`, Hammerspoon will\nblock until all missing Spoons are installed, but the notifications\nwill happen at a more \"human readable\" rate.",
        "name": "use_syncinstall",
        "signature": "SpoonInstall.use_syncinstall",
        "stripped_doc": "Keep in mind that if you set this to `true`, Hammerspoon will\nblock until all missing Spoons are installed, but the notifications\nwill happen at a more \"human readable\" rate.",
        "type": "Variable"
      }
    ],
    "desc": "Install and manage Spoons and Spoon repositories",
    "doc": "Install and manage Spoons and Spoon repositories\n\nDownload: [https://github.com/Hammerspoon/Spoons/raw/master/Spoons/SpoonInstall.spoon.zip](https://github.com/Hammerspoon/Spoons/raw/master/Spoons/SpoonInstall.spoon.zip)",
    "items": [
      {
        "def": "SpoonInstall:andUse(name, arg)",
        "desc": "Declaratively install, load and configure a Spoon",
        "doc": "Declaratively install, load and configure a Spoon\n\nParameters:\n * name - the name of the Spoon to install (without the `.spoon` extension). If the Spoon is already installed, it will be loaded using `hs.loadSpoon()`. If it is not installed, it will be installed using `SpoonInstall:asyncInstallSpoonFromRepo()` and then loaded.\n * arg - if provided, can be used to specify the configuration of the Spoon. The following keys are recognized (all are optional):\n   * repo - repository from where the Spoon should be installed if not present in the system, as defined in `SpoonInstall.repos`. Defaults to `\"default\"`.\n   * config - a table containing variables to be stored in the Spoon object to configure it. For example, `config = { answer = 42 }` will result in `spoon.<LoadedSpoon>.answer` being set to 42.\n   * hotkeys - a table containing hotkey bindings. If provided, will be passed as-is to the Spoon's `bindHotkeys()` method. The special string `\"default\"` can be given to use the Spoons `defaultHotkeys` variable, if it exists.\n   * fn - a function which will be called with the freshly-loaded Spoon object as its first argument.\n   * loglevel - if the Spoon has a variable called `logger`, its `setLogLevel()` method will be called with this value.\n   * start - if `true`, call the Spoon's `start()` method after configuring everything else.\n   * disable - if `true`, do nothing. Easier than commenting it out when you want to temporarily disable a spoon.\n\nReturns:\n * None",
        "name": "andUse",
        "parameters": [
          " * name - the name of the Spoon to install (without the `.spoon` extension). If the Spoon is already installed, it will be loaded using `hs.loadSpoon()`. If it is not installed, it will be installed using `SpoonInstall:asyncInstallSpoonFromRepo()` and then loaded.",
          " * arg - if provided, can be used to specify the configuration of the Spoon. The following keys are recognized (all are optional):",
          "   * repo - repository from where the Spoon should be installed if not present in the system, as defined in `SpoonInstall.repos`. Defaults to `\"default\"`.",
          "   * config - a table containing variables to be stored in the Spoon object to configure it. For example, `config = { answer = 42 }` will result in `spoon.<LoadedSpoon>.answer` being set to 42.",
          "   * hotkeys - a table containing hotkey bindings. If provided, will be passed as-is to the Spoon's `bindHotkeys()` method. The special string `\"default\"` can be given to use the Spoons `defaultHotkeys` variable, if it exists.",
          "   * fn - a function which will be called with the freshly-loaded Spoon object as its first argument.",
          "   * loglevel - if the Spoon has a variable called `logger`, its `setLogLevel()` method will be called with this value.",
          "   * start - if `true`, call the Spoon's `start()` method after configuring everything else.",
          "   * disable - if `true`, do nothing. Easier than commenting it out when you want to temporarily disable a spoon."
        ],
        "returns": [
          " * None"
        ],
        "signature": "SpoonInstall:andUse(name, arg)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "SpoonInstall:asyncInstallSpoonFromRepo(name, repo, callback)",
        "desc": "Asynchronously install a Spoon from a registered repository",
        "doc": "Asynchronously install a Spoon from a registered repository\n\nParameters:\n * name - Name of the Spoon to install.\n * repo - Name of the repository to use. Defaults to `\"default\"`\n * callback - if given, a function to call after the installation finishes (also if it fails). The function receives the following arguments:\n   * urlparts - Result of calling `hs.http.urlParts` on the URL of the Spoon zip file\n   * success - boolean indicating whether the installation was successful\n\nReturns:\n * `true` if the installation was correctly initiated (i.e. the repo and spoon name were correct), `false` otherwise.",
        "name": "asyncInstallSpoonFromRepo",
        "parameters": [
          " * name - Name of the Spoon to install.",
          " * repo - Name of the repository to use. Defaults to `\"default\"`",
          " * callback - if given, a function to call after the installation finishes (also if it fails). The function receives the following arguments:",
          "   * urlparts - Result of calling `hs.http.urlParts` on the URL of the Spoon zip file",
          "   * success - boolean indicating whether the installation was successful"
        ],
        "returns": [
          " * `true` if the installation was correctly initiated (i.e. the repo and spoon name were correct), `false` otherwise."
        ],
        "signature": "SpoonInstall:asyncInstallSpoonFromRepo(name, repo, callback)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "SpoonInstall:asyncInstallSpoonFromZipURL(url, callback)",
        "desc": "Asynchronously download a Spoon zip file and install it.",
        "doc": "Asynchronously download a Spoon zip file and install it.\n\nParameters:\n * url - URL of the zip file to install.\n * callback - if given, a function to call after the installation finishes (also if it fails). The function receives the following arguments:\n   * urlparts - Result of calling `hs.http.urlParts` on the URL of the Spoon zip file\n   * success - boolean indicating whether the installation was successful\n\nReturns:\n * `true` if the installation was correctly initiated (i.e. the URL is valid), `false` otherwise",
        "name": "asyncInstallSpoonFromZipURL",
        "parameters": [
          " * url - URL of the zip file to install.",
          " * callback - if given, a function to call after the installation finishes (also if it fails). The function receives the following arguments:",
          "   * urlparts - Result of calling `hs.http.urlParts` on the URL of the Spoon zip file",
          "   * success - boolean indicating whether the installation was successful"
        ],
        "returns": [
          " * `true` if the installation was correctly initiated (i.e. the URL is valid), `false` otherwise"
        ],
        "signature": "SpoonInstall:asyncInstallSpoonFromZipURL(url, callback)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "SpoonInstall:asyncUpdateRepo(repo, callback)",
        "desc": "Asynchronously fetch the information about the contents of a Spoon repository",
        "doc": "Asynchronously fetch the information about the contents of a Spoon repository\n\nParameters:\n * repo - name of the repository to update. Defaults to `\"default\"`.\n * callback - if given, a function to be called after the update finishes (also if it fails). The function will receive the following arguments:\n   * repo - name of the repository\n   * success - boolean indicating whether the update succeeded\n\nReturns:\n * `true` if the update was correctly initiated (i.e. the repo name is valid), `nil` otherwise\n\nNotes:\n * For now, the repository data is not persisted, so you need to update it after every restart if you want to use any of the install functions.",
        "name": "asyncUpdateRepo",
        "notes": [
          " * For now, the repository data is not persisted, so you need to update it after every restart if you want to use any of the install functions."
        ],
        "parameters": [
          " * repo - name of the repository to update. Defaults to `\"default\"`.",
          " * callback - if given, a function to be called after the update finishes (also if it fails). The function will receive the following arguments:",
          "   * repo - name of the repository",
          "   * success - boolean indicating whether the update succeeded"
        ],
        "returns": [
          " * `true` if the update was correctly initiated (i.e. the repo name is valid), `nil` otherwise"
        ],
        "signature": "SpoonInstall:asyncUpdateRepo(repo, callback)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "SpoonInstall:installSpoonFromRepo(name, repo)",
        "desc": "Synchronously install a Spoon from a registered repository",
        "doc": "Synchronously install a Spoon from a registered repository\n\nParameters:\n * name = Name of the Spoon to install.\n * repo - Name of the repository to use. Defaults to `\"default\"`\n\nReturns:\n * `true` if the installation was successful, `nil` otherwise.",
        "name": "installSpoonFromRepo",
        "parameters": [
          " * name = Name of the Spoon to install.",
          " * repo - Name of the repository to use. Defaults to `\"default\"`"
        ],
        "returns": [
          " * `true` if the installation was successful, `nil` otherwise."
        ],
        "signature": "SpoonInstall:installSpoonFromRepo(name, repo)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "SpoonInstall:installSpoonFromZipURL(url)",
        "desc": "Synchronously download a Spoon zip file and install it.",
        "doc": "Synchronously download a Spoon zip file and install it.\n\nParameters:\n * url - URL of the zip file to install.\n\nReturns:\n * `true` if the installation was successful, `nil` otherwise",
        "name": "installSpoonFromZipURL",
        "parameters": [
          " * url - URL of the zip file to install."
        ],
        "returns": [
          " * `true` if the installation was successful, `nil` otherwise"
        ],
        "signature": "SpoonInstall:installSpoonFromZipURL(url)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "SpoonInstall.logger",
        "desc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "doc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "name": "logger",
        "signature": "SpoonInstall.logger",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "SpoonInstall:repolist()",
        "desc": "Return a sorted list of registered Spoon repositories",
        "doc": "Return a sorted list of registered Spoon repositories\n\nParameters:\n * None\n\nReturns:\n * Table containing a list of strings with the repository identifiers",
        "name": "repolist",
        "parameters": [
          " * None"
        ],
        "returns": [
          " * Table containing a list of strings with the repository identifiers"
        ],
        "signature": "SpoonInstall:repolist()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "SpoonInstall.repos",
        "desc": "Table containing the list of available Spoon repositories. The key",
        "doc": "Table containing the list of available Spoon repositories. The key\nof each entry is an identifier for the repository, and its value\nis a table with the following entries:\n * desc - Human-readable description for the repository\n * url - Base URL for the repository. For now the repository is assumed to be hosted in GitHub, and the URL should be the main base URL of the repository. Repository metadata needs to be stored under `docs/docs.json`, and the Spoon zip files need to be stored under `Spoons/`.\n\nDefault value:\n```\n{\n   default = {\n      url = \"https://github.com/Hammerspoon/Spoons\",\n      desc = \"Main Hammerspoon Spoon repository\",\n   }\n}\n```",
        "name": "repos",
        "signature": "SpoonInstall.repos",
        "stripped_doc": "of each entry is an identifier for the repository, and its value\nis a table with the following entries:\n * desc - Human-readable description for the repository\n * url - Base URL for the repository. For now the repository is assumed to be hosted in GitHub, and the URL should be the main base URL of the repository. Repository metadata needs to be stored under `docs/docs.json`, and the Spoon zip files need to be stored under `Spoons/`.\nDefault value:\n```\n{\n   default = {\n      url = \"https://github.com/Hammerspoon/Spoons\",\n      desc = \"Main Hammerspoon Spoon repository\",\n   }\n}\n```",
        "type": "Variable"
      },
      {
        "def": "SpoonInstall:search(pat)",
        "desc": "Search repositories for a pattern",
        "doc": "Search repositories for a pattern\n\nParameters:\n * pat - Lua pattern that will be matched against the name and description of each spoon in the registered repositories. All text is converted to lowercase before searching it, so you can use all-lowercase in your pattern.\n\nReturns:\n * Table containing a list of matching entries. Each entry is a table with the following keys:\n   * name - Spoon name\n   * desc - description of the spoon\n   * repo - identifier in the repository where the match was found",
        "name": "search",
        "parameters": [
          " * pat - Lua pattern that will be matched against the name and description of each spoon in the registered repositories. All text is converted to lowercase before searching it, so you can use all-lowercase in your pattern."
        ],
        "returns": [
          " * Table containing a list of matching entries. Each entry is a table with the following keys:",
          "   * name - Spoon name",
          "   * desc - description of the spoon",
          "   * repo - identifier in the repository where the match was found"
        ],
        "signature": "SpoonInstall:search(pat)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "SpoonInstall:updateAllRepos()",
        "desc": "Synchronously fetch the information about the contents of all Spoon repositories registered in `SpoonInstall.repos`",
        "doc": "Synchronously fetch the information about the contents of all Spoon repositories registered in `SpoonInstall.repos`\n\nParameters:\n * None\n\nReturns:\n * None\n\nNotes:\n * This is a synchronous call, which means Hammerspoon will be blocked until it finishes.\n * For now, the repository data is not persisted, so you need to update it after every restart if you want to use any of the install functions.",
        "name": "updateAllRepos",
        "notes": [
          " * This is a synchronous call, which means Hammerspoon will be blocked until it finishes.",
          " * For now, the repository data is not persisted, so you need to update it after every restart if you want to use any of the install functions."
        ],
        "parameters": [
          " * None"
        ],
        "returns": [
          " * None"
        ],
        "signature": "SpoonInstall:updateAllRepos()",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "SpoonInstall:updateRepo(repo)",
        "desc": "Synchronously fetch the information about the contents of a Spoon repository",
        "doc": "Synchronously fetch the information about the contents of a Spoon repository\n\nParameters:\n * repo - name of the repository to update. Defaults to `\"default\"`.\n\nReturns:\n * `true` if the update was successful, `nil` otherwise\n\nNotes:\n * This is a synchronous call, which means Hammerspoon will be blocked until it finishes. For use in your configuration files, it's advisable to use `SpoonInstall.asyncUpdateRepo()` instead.\n * For now, the repository data is not persisted, so you need to update it after every restart if you want to use any of the install functions.",
        "name": "updateRepo",
        "notes": [
          " * This is a synchronous call, which means Hammerspoon will be blocked until it finishes. For use in your configuration files, it's advisable to use `SpoonInstall.asyncUpdateRepo()` instead.",
          " * For now, the repository data is not persisted, so you need to update it after every restart if you want to use any of the install functions."
        ],
        "parameters": [
          " * repo - name of the repository to update. Defaults to `\"default\"`."
        ],
        "returns": [
          " * `true` if the update was successful, `nil` otherwise"
        ],
        "signature": "SpoonInstall:updateRepo(repo)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "SpoonInstall.use_syncinstall",
        "desc": "If `true`, `andUse()` will update repos and install packages synchronously. Defaults to `false`.",
        "doc": "If `true`, `andUse()` will update repos and install packages synchronously. Defaults to `false`.\n\nKeep in mind that if you set this to `true`, Hammerspoon will\nblock until all missing Spoons are installed, but the notifications\nwill happen at a more \"human readable\" rate.",
        "name": "use_syncinstall",
        "signature": "SpoonInstall.use_syncinstall",
        "stripped_doc": "Keep in mind that if you set this to `true`, Hammerspoon will\nblock until all missing Spoons are installed, but the notifications\nwill happen at a more \"human readable\" rate.",
        "type": "Variable"
      }
    ],
    "name": "SpoonInstall",
    "stripped_doc": "\nDownload: [https://github.com/Hammerspoon/Spoons/raw/master/Spoons/SpoonInstall.spoon.zip](https://github.com/Hammerspoon/Spoons/raw/master/Spoons/SpoonInstall.spoon.zip)",
    "submodules": [],
    "type": "Module"
  },
  {
    "Command": [],
    "Constant": [],
    "Constructor": [],
    "Deprecated": [],
    "Field": [],
    "Function": [],
    "Method": [
      {
        "def": "WindowGrid:bindHotkeys(mapping)",
        "desc": "Binds hotkeys for WindowGrid",
        "doc": "Binds hotkeys for WindowGrid\n\nParameters:\n * mapping - A table containing hotkey objifier/key details for the following items:\n  * show_grid - show the grid overlay",
        "name": "bindHotkeys",
        "parameters": [
          " * mapping - A table containing hotkey objifier/key details for the following items:",
          "  * show_grid - show the grid overlay"
        ],
        "signature": "WindowGrid:bindHotkeys(mapping)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "WindowGrid:start()",
        "desc": "Sets the grid configuration according to `WindowGrid.gridGeometries`.",
        "doc": "Sets the grid configuration according to `WindowGrid.gridGeometries`.",
        "name": "start",
        "signature": "WindowGrid:start()",
        "stripped_doc": "",
        "type": "Method"
      }
    ],
    "Variable": [
      {
        "def": "WindowGrid.gridGeometries",
        "desc": "Table containing a list of arguments to be passed to grid.setGrid(). Each element in the table is itself a table with 1-3 arguments as defined for [hs.grid.setGrid()](http://www.hammerspoon.org/docs/hs.grid.html#setGrid). Defaults to an empty list, which results in the default 3x3 grid for all screen from `hs.grid`.",
        "doc": "Table containing a list of arguments to be passed to grid.setGrid(). Each element in the table is itself a table with 1-3 arguments as defined for [hs.grid.setGrid()](http://www.hammerspoon.org/docs/hs.grid.html#setGrid). Defaults to an empty list, which results in the default 3x3 grid for all screen from `hs.grid`.",
        "name": "gridGeometries",
        "signature": "WindowGrid.gridGeometries",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "WindowGrid.logger",
        "desc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "doc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "name": "logger",
        "signature": "WindowGrid.logger",
        "stripped_doc": "",
        "type": "Variable"
      }
    ],
    "desc": "Configure and assign hotkey for `hs.grid`",
    "doc": "Configure and assign hotkey for `hs.grid`\n\nDownload: [https://github.com/Hammerspoon/Spoons/raw/master/Spoons/WindowGrid.spoon.zip](https://github.com/Hammerspoon/Spoons/raw/master/Spoons/WindowGrid.spoon.zip)",
    "items": [
      {
        "def": "WindowGrid:bindHotkeys(mapping)",
        "desc": "Binds hotkeys for WindowGrid",
        "doc": "Binds hotkeys for WindowGrid\n\nParameters:\n * mapping - A table containing hotkey objifier/key details for the following items:\n  * show_grid - show the grid overlay",
        "name": "bindHotkeys",
        "parameters": [
          " * mapping - A table containing hotkey objifier/key details for the following items:",
          "  * show_grid - show the grid overlay"
        ],
        "signature": "WindowGrid:bindHotkeys(mapping)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "WindowGrid.gridGeometries",
        "desc": "Table containing a list of arguments to be passed to grid.setGrid(). Each element in the table is itself a table with 1-3 arguments as defined for [hs.grid.setGrid()](http://www.hammerspoon.org/docs/hs.grid.html#setGrid). Defaults to an empty list, which results in the default 3x3 grid for all screen from `hs.grid`.",
        "doc": "Table containing a list of arguments to be passed to grid.setGrid(). Each element in the table is itself a table with 1-3 arguments as defined for [hs.grid.setGrid()](http://www.hammerspoon.org/docs/hs.grid.html#setGrid). Defaults to an empty list, which results in the default 3x3 grid for all screen from `hs.grid`.",
        "name": "gridGeometries",
        "signature": "WindowGrid.gridGeometries",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "WindowGrid.logger",
        "desc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "doc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "name": "logger",
        "signature": "WindowGrid.logger",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "WindowGrid:start()",
        "desc": "Sets the grid configuration according to `WindowGrid.gridGeometries`.",
        "doc": "Sets the grid configuration according to `WindowGrid.gridGeometries`.",
        "name": "start",
        "signature": "WindowGrid:start()",
        "stripped_doc": "",
        "type": "Method"
      }
    ],
    "name": "WindowGrid",
    "stripped_doc": "\nDownload: [https://github.com/Hammerspoon/Spoons/raw/master/Spoons/WindowGrid.spoon.zip](https://github.com/Hammerspoon/Spoons/raw/master/Spoons/WindowGrid.spoon.zip)",
    "submodules": [],
    "type": "Module"
  },
  {
    "Command": [],
    "Constant": [],
    "Constructor": [],
    "Deprecated": [],
    "Field": [],
    "Function": [],
    "Method": [
      {
        "def": "WindowHalfsAndThirds:bindHotkeys(mapping)",
        "desc": "Binds hotkeys for WindowHalfsAndThirds",
        "doc": "Binds hotkeys for WindowHalfsAndThirds\n\nParameters:\n * mapping - A table containing hotkey objifier/key details for the following items:\n  * left_half, right_half, top_half, bottom_half - resize to the corresponding half of the screen\n  * third_left, third_right - resize to one horizontal-third of the screen and move left/right\n  * third_up, third_down - resize to one vertical-third of the screen and move up/down\n  * max - maximize the window\n  * max_toggle - toggle maximization\n  * screen_left, screen_right - move the window to the left/right screen (if you have more than one monitor connected, does nothing otherwise)\n  * top_third, middle_third_v, bottom_third - resize and move the window to the corresponding vertical third of the screen\n  * left_third, middle_third_h, right_third - resize and move the window to the corresponding horizontal third of the screen\n  * top_left, top_right, bottom_left, bottom_right - resize and move the window to the corresponding quarter of the screen",
        "name": "bindHotkeys",
        "parameters": [
          " * mapping - A table containing hotkey objifier/key details for the following items:",
          "  * left_half, right_half, top_half, bottom_half - resize to the corresponding half of the screen",
          "  * third_left, third_right - resize to one horizontal-third of the screen and move left/right",
          "  * third_up, third_down - resize to one vertical-third of the screen and move up/down",
          "  * max - maximize the window",
          "  * max_toggle - toggle maximization",
          "  * screen_left, screen_right - move the window to the left/right screen (if you have more than one monitor connected, does nothing otherwise)",
          "  * top_third, middle_third_v, bottom_third - resize and move the window to the corresponding vertical third of the screen",
          "  * left_third, middle_third_h, right_third - resize and move the window to the corresponding horizontal third of the screen",
          "  * top_left, top_right, bottom_left, bottom_right - resize and move the window to the corresponding quarter of the screen"
        ],
        "signature": "WindowHalfsAndThirds:bindHotkeys(mapping)",
        "stripped_doc": "",
        "type": "Method"
      }
    ],
    "Variable": [
      {
        "def": "WindowHalfsAndThirds.defaultHotkeys",
        "desc": "Table containing a sample set of hotkeys that can be",
        "doc": "Table containing a sample set of hotkeys that can be\nassigned to the different operations. These are not bound\nby default - if you want to use them you have to call:\n`spoon.WindowHalfsAndThirds:bindHotkeys(spoon.WindowHalfsAndThirds.defaultHotkeys)`\nafter loading the spoon. Value:\n```\n {\n    left_half   = { {\"ctrl\",        \"cmd\"}, \"Left\" },\n    right_half  = { {\"ctrl\",        \"cmd\"}, \"Right\" },\n    top_half    = { {\"ctrl\",        \"cmd\"}, \"Up\" },\n    bottom_half = { {\"ctrl\",        \"cmd\"}, \"Down\" },\n    third_left  = { {\"ctrl\", \"alt\"       }, \"Left\" },\n    third_right = { {\"ctrl\", \"alt\"       }, \"Right\" },\n    third_up    = { {\"ctrl\", \"alt\"       }, \"Up\" },\n    third_down  = { {\"ctrl\", \"alt\"       }, \"Down\" },\n    top_left    = { {\"ctrl\",        \"cmd\"}, \"1\" },\n    top_right   = { {\"ctrl\",        \"cmd\"}, \"2\" },\n    bottom_left = { {\"ctrl\",        \"cmd\"}, \"3\" },\n    bottom_right= { {\"ctrl\",        \"cmd\"}, \"4\" },\n    max_toggle  = { {\"ctrl\", \"alt\", \"cmd\"}, \"f\" },\n    max         = { {\"ctrl\", \"alt\", \"cmd\"}, \"Up\" },\n }\n```",
        "name": "defaultHotkeys",
        "signature": "WindowHalfsAndThirds.defaultHotkeys",
        "stripped_doc": "assigned to the different operations. These are not bound\nby default - if you want to use them you have to call:\n`spoon.WindowHalfsAndThirds:bindHotkeys(spoon.WindowHalfsAndThirds.defaultHotkeys)`\nafter loading the spoon. Value:\n```\n {\n    left_half   = { {\"ctrl\",        \"cmd\"}, \"Left\" },\n    right_half  = { {\"ctrl\",        \"cmd\"}, \"Right\" },\n    top_half    = { {\"ctrl\",        \"cmd\"}, \"Up\" },\n    bottom_half = { {\"ctrl\",        \"cmd\"}, \"Down\" },\n    third_left  = { {\"ctrl\", \"alt\"       }, \"Left\" },\n    third_right = { {\"ctrl\", \"alt\"       }, \"Right\" },\n    third_up    = { {\"ctrl\", \"alt\"       }, \"Up\" },\n    third_down  = { {\"ctrl\", \"alt\"       }, \"Down\" },\n    top_left    = { {\"ctrl\",        \"cmd\"}, \"1\" },\n    top_right   = { {\"ctrl\",        \"cmd\"}, \"2\" },\n    bottom_left = { {\"ctrl\",        \"cmd\"}, \"3\" },\n    bottom_right= { {\"ctrl\",        \"cmd\"}, \"4\" },\n    max_toggle  = { {\"ctrl\", \"alt\", \"cmd\"}, \"f\" },\n    max         = { {\"ctrl\", \"alt\", \"cmd\"}, \"Up\" },\n }\n```",
        "type": "Variable"
      },
      {
        "def": "WindowHalfsAndThirds.logger",
        "desc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "doc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "name": "logger",
        "signature": "WindowHalfsAndThirds.logger",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "WindowHalfsAndThirds.use_frame_correctness",
        "desc": "If `true`, set [setFrameCorrectness](http://www.hammerspoon.org/docs/hs.window.html#setFrameCorrectness) for some resizing operations which fail when the window extends beyonds screen boundaries. This may cause some jerkiness in the resizing, so experiment and determine if you need it. Defaults to `false`",
        "doc": "If `true`, set [setFrameCorrectness](http://www.hammerspoon.org/docs/hs.window.html#setFrameCorrectness) for some resizing operations which fail when the window extends beyonds screen boundaries. This may cause some jerkiness in the resizing, so experiment and determine if you need it. Defaults to `false`",
        "name": "use_frame_correctness",
        "signature": "WindowHalfsAndThirds.use_frame_correctness",
        "stripped_doc": "",
        "type": "Variable"
      }
    ],
    "desc": "Simple window movement and resizing, focusing on half- and third-of-screen sizes",
    "doc": "Simple window movement and resizing, focusing on half- and third-of-screen sizes\n\nDownload: [https://github.com/Hammerspoon/Spoons/raw/master/Spoons/WindowHalfsAndThirds.spoon.zip](https://github.com/Hammerspoon/Spoons/raw/master/Spoons/WindowHalfsAndThirds.spoon.zip)",
    "items": [
      {
        "def": "WindowHalfsAndThirds:bindHotkeys(mapping)",
        "desc": "Binds hotkeys for WindowHalfsAndThirds",
        "doc": "Binds hotkeys for WindowHalfsAndThirds\n\nParameters:\n * mapping - A table containing hotkey objifier/key details for the following items:\n  * left_half, right_half, top_half, bottom_half - resize to the corresponding half of the screen\n  * third_left, third_right - resize to one horizontal-third of the screen and move left/right\n  * third_up, third_down - resize to one vertical-third of the screen and move up/down\n  * max - maximize the window\n  * max_toggle - toggle maximization\n  * screen_left, screen_right - move the window to the left/right screen (if you have more than one monitor connected, does nothing otherwise)\n  * top_third, middle_third_v, bottom_third - resize and move the window to the corresponding vertical third of the screen\n  * left_third, middle_third_h, right_third - resize and move the window to the corresponding horizontal third of the screen\n  * top_left, top_right, bottom_left, bottom_right - resize and move the window to the corresponding quarter of the screen",
        "name": "bindHotkeys",
        "parameters": [
          " * mapping - A table containing hotkey objifier/key details for the following items:",
          "  * left_half, right_half, top_half, bottom_half - resize to the corresponding half of the screen",
          "  * third_left, third_right - resize to one horizontal-third of the screen and move left/right",
          "  * third_up, third_down - resize to one vertical-third of the screen and move up/down",
          "  * max - maximize the window",
          "  * max_toggle - toggle maximization",
          "  * screen_left, screen_right - move the window to the left/right screen (if you have more than one monitor connected, does nothing otherwise)",
          "  * top_third, middle_third_v, bottom_third - resize and move the window to the corresponding vertical third of the screen",
          "  * left_third, middle_third_h, right_third - resize and move the window to the corresponding horizontal third of the screen",
          "  * top_left, top_right, bottom_left, bottom_right - resize and move the window to the corresponding quarter of the screen"
        ],
        "signature": "WindowHalfsAndThirds:bindHotkeys(mapping)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "WindowHalfsAndThirds.defaultHotkeys",
        "desc": "Table containing a sample set of hotkeys that can be",
        "doc": "Table containing a sample set of hotkeys that can be\nassigned to the different operations. These are not bound\nby default - if you want to use them you have to call:\n`spoon.WindowHalfsAndThirds:bindHotkeys(spoon.WindowHalfsAndThirds.defaultHotkeys)`\nafter loading the spoon. Value:\n```\n {\n    left_half   = { {\"ctrl\",        \"cmd\"}, \"Left\" },\n    right_half  = { {\"ctrl\",        \"cmd\"}, \"Right\" },\n    top_half    = { {\"ctrl\",        \"cmd\"}, \"Up\" },\n    bottom_half = { {\"ctrl\",        \"cmd\"}, \"Down\" },\n    third_left  = { {\"ctrl\", \"alt\"       }, \"Left\" },\n    third_right = { {\"ctrl\", \"alt\"       }, \"Right\" },\n    third_up    = { {\"ctrl\", \"alt\"       }, \"Up\" },\n    third_down  = { {\"ctrl\", \"alt\"       }, \"Down\" },\n    top_left    = { {\"ctrl\",        \"cmd\"}, \"1\" },\n    top_right   = { {\"ctrl\",        \"cmd\"}, \"2\" },\n    bottom_left = { {\"ctrl\",        \"cmd\"}, \"3\" },\n    bottom_right= { {\"ctrl\",        \"cmd\"}, \"4\" },\n    max_toggle  = { {\"ctrl\", \"alt\", \"cmd\"}, \"f\" },\n    max         = { {\"ctrl\", \"alt\", \"cmd\"}, \"Up\" },\n }\n```",
        "name": "defaultHotkeys",
        "signature": "WindowHalfsAndThirds.defaultHotkeys",
        "stripped_doc": "assigned to the different operations. These are not bound\nby default - if you want to use them you have to call:\n`spoon.WindowHalfsAndThirds:bindHotkeys(spoon.WindowHalfsAndThirds.defaultHotkeys)`\nafter loading the spoon. Value:\n```\n {\n    left_half   = { {\"ctrl\",        \"cmd\"}, \"Left\" },\n    right_half  = { {\"ctrl\",        \"cmd\"}, \"Right\" },\n    top_half    = { {\"ctrl\",        \"cmd\"}, \"Up\" },\n    bottom_half = { {\"ctrl\",        \"cmd\"}, \"Down\" },\n    third_left  = { {\"ctrl\", \"alt\"       }, \"Left\" },\n    third_right = { {\"ctrl\", \"alt\"       }, \"Right\" },\n    third_up    = { {\"ctrl\", \"alt\"       }, \"Up\" },\n    third_down  = { {\"ctrl\", \"alt\"       }, \"Down\" },\n    top_left    = { {\"ctrl\",        \"cmd\"}, \"1\" },\n    top_right   = { {\"ctrl\",        \"cmd\"}, \"2\" },\n    bottom_left = { {\"ctrl\",        \"cmd\"}, \"3\" },\n    bottom_right= { {\"ctrl\",        \"cmd\"}, \"4\" },\n    max_toggle  = { {\"ctrl\", \"alt\", \"cmd\"}, \"f\" },\n    max         = { {\"ctrl\", \"alt\", \"cmd\"}, \"Up\" },\n }\n```",
        "type": "Variable"
      },
      {
        "def": "WindowHalfsAndThirds.logger",
        "desc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "doc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "name": "logger",
        "signature": "WindowHalfsAndThirds.logger",
        "stripped_doc": "",
        "type": "Variable"
      },
      {
        "def": "WindowHalfsAndThirds.use_frame_correctness",
        "desc": "If `true`, set [setFrameCorrectness](http://www.hammerspoon.org/docs/hs.window.html#setFrameCorrectness) for some resizing operations which fail when the window extends beyonds screen boundaries. This may cause some jerkiness in the resizing, so experiment and determine if you need it. Defaults to `false`",
        "doc": "If `true`, set [setFrameCorrectness](http://www.hammerspoon.org/docs/hs.window.html#setFrameCorrectness) for some resizing operations which fail when the window extends beyonds screen boundaries. This may cause some jerkiness in the resizing, so experiment and determine if you need it. Defaults to `false`",
        "name": "use_frame_correctness",
        "signature": "WindowHalfsAndThirds.use_frame_correctness",
        "stripped_doc": "",
        "type": "Variable"
      }
    ],
    "name": "WindowHalfsAndThirds",
    "stripped_doc": "\nDownload: [https://github.com/Hammerspoon/Spoons/raw/master/Spoons/WindowHalfsAndThirds.spoon.zip](https://github.com/Hammerspoon/Spoons/raw/master/Spoons/WindowHalfsAndThirds.spoon.zip)",
    "submodules": [],
    "type": "Module"
  },
  {
    "Command": [],
    "Constant": [],
    "Constructor": [],
    "Deprecated": [],
    "Field": [],
    "Function": [],
    "Method": [
      {
        "def": "WindowScreenLeftAndRight:bindHotkeys(mapping)",
        "desc": "Binds hotkeys for WindowScreenLeftAndRight",
        "doc": "Binds hotkeys for WindowScreenLeftAndRight\n\nParameters:\n * mapping - A table containing hotkey objifier/key details for the following items:\n  * screen_left, screen_right - move the window to the left/right screen (if you have more than one monitor connected, does nothing otherwise)",
        "name": "bindHotkeys",
        "parameters": [
          " * mapping - A table containing hotkey objifier/key details for the following items:",
          "  * screen_left, screen_right - move the window to the left/right screen (if you have more than one monitor connected, does nothing otherwise)"
        ],
        "signature": "WindowScreenLeftAndRight:bindHotkeys(mapping)",
        "stripped_doc": "",
        "type": "Method"
      }
    ],
    "Variable": [
      {
        "def": "WindowScreenLeftAndRight.defaultHotkeys",
        "desc": "Table containing a sample set of hotkeys that can be",
        "doc": "Table containing a sample set of hotkeys that can be\nassigned to the different operations. These are not bound\nby default - if you want to use them you have to call:\n`spoon.WindowScreenLeftAndRight:bindHotkeys(spoon.WindowScreenLeftAndRight.defaultHotkeys)`\nafter loading the spoon. Value:\n```\n {\n    screen_left = { {\"ctrl\", \"alt\", \"cmd\"}, \"Left\" },\n    screen_right= { {\"ctrl\", \"alt\", \"cmd\"}, \"Right\" },\n }\n```",
        "name": "defaultHotkeys",
        "signature": "WindowScreenLeftAndRight.defaultHotkeys",
        "stripped_doc": "assigned to the different operations. These are not bound\nby default - if you want to use them you have to call:\n`spoon.WindowScreenLeftAndRight:bindHotkeys(spoon.WindowScreenLeftAndRight.defaultHotkeys)`\nafter loading the spoon. Value:\n```\n {\n    screen_left = { {\"ctrl\", \"alt\", \"cmd\"}, \"Left\" },\n    screen_right= { {\"ctrl\", \"alt\", \"cmd\"}, \"Right\" },\n }\n```",
        "type": "Variable"
      },
      {
        "def": "WindowScreenLeftAndRight.logger",
        "desc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "doc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "name": "logger",
        "signature": "WindowScreenLeftAndRight.logger",
        "stripped_doc": "",
        "type": "Variable"
      }
    ],
    "desc": "Move windows to other screens",
    "doc": "Move windows to other screens\n\nDownload: [https://github.com/Hammerspoon/Spoons/raw/master/Spoons/WindowScreenLeftAndRight.spoon.zip](https://github.com/Hammerspoon/Spoons/raw/master/Spoons/WindowScreenLeftAndRight.spoon.zip)",
    "items": [
      {
        "def": "WindowScreenLeftAndRight:bindHotkeys(mapping)",
        "desc": "Binds hotkeys for WindowScreenLeftAndRight",
        "doc": "Binds hotkeys for WindowScreenLeftAndRight\n\nParameters:\n * mapping - A table containing hotkey objifier/key details for the following items:\n  * screen_left, screen_right - move the window to the left/right screen (if you have more than one monitor connected, does nothing otherwise)",
        "name": "bindHotkeys",
        "parameters": [
          " * mapping - A table containing hotkey objifier/key details for the following items:",
          "  * screen_left, screen_right - move the window to the left/right screen (if you have more than one monitor connected, does nothing otherwise)"
        ],
        "signature": "WindowScreenLeftAndRight:bindHotkeys(mapping)",
        "stripped_doc": "",
        "type": "Method"
      },
      {
        "def": "WindowScreenLeftAndRight.defaultHotkeys",
        "desc": "Table containing a sample set of hotkeys that can be",
        "doc": "Table containing a sample set of hotkeys that can be\nassigned to the different operations. These are not bound\nby default - if you want to use them you have to call:\n`spoon.WindowScreenLeftAndRight:bindHotkeys(spoon.WindowScreenLeftAndRight.defaultHotkeys)`\nafter loading the spoon. Value:\n```\n {\n    screen_left = { {\"ctrl\", \"alt\", \"cmd\"}, \"Left\" },\n    screen_right= { {\"ctrl\", \"alt\", \"cmd\"}, \"Right\" },\n }\n```",
        "name": "defaultHotkeys",
        "signature": "WindowScreenLeftAndRight.defaultHotkeys",
        "stripped_doc": "assigned to the different operations. These are not bound\nby default - if you want to use them you have to call:\n`spoon.WindowScreenLeftAndRight:bindHotkeys(spoon.WindowScreenLeftAndRight.defaultHotkeys)`\nafter loading the spoon. Value:\n```\n {\n    screen_left = { {\"ctrl\", \"alt\", \"cmd\"}, \"Left\" },\n    screen_right= { {\"ctrl\", \"alt\", \"cmd\"}, \"Right\" },\n }\n```",
        "type": "Variable"
      },
      {
        "def": "WindowScreenLeftAndRight.logger",
        "desc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "doc": "Logger object used within the Spoon. Can be accessed to set the default log level for the messages coming from the Spoon.",
        "name": "logger",
        "signature": "WindowScreenLeftAndRight.logger",
        "stripped_doc": "",
        "type": "Variable"
      }
    ],
    "name": "WindowScreenLeftAndRight",
    "stripped_doc": "\nDownload: [https://github.com/Hammerspoon/Spoons/raw/master/Spoons/WindowScreenLeftAndRight.spoon.zip](https://github.com/Hammerspoon/Spoons/raw/master/Spoons/WindowScreenLeftAndRight.spoon.zip)",
    "submodules": [],
    "type": "Module"
  }
]